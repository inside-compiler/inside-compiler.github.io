---
title: inline_cache_design
categories:
  - vm
tags:
  - vm
date: 2025-03-21 23:33:24
---

## 背景

动态语言的符号绑定是动态的，会随着程序的执行而发生变化，因此，在程序执行过程中需要先获取符号的地址，才能执行符号对应的代码。这相比静态语言程序执行多了符号查找的开销，因为静态语言的符号都在编译时静态绑定了，所以它可以在程序执行过程中直接执行符号对应的代码。这也是许多动态语言性能不如静态语言的原因之一。（如下例子）

为什么动态语言的符号绑定是动态的呢？有个原因是因为动态语言的对象类型是动态的，导致在运行之前无法根据类型确定对象的布局，从而无法确定符号的地址。但是为了提高动态语言的性能，有需要尽可能地降低这些符号绑定的开销。因此，人们根据局部性原理提出了一些投机和缓存的算法，其中一个称为in-line cache。这个优化是在动态语言的执行环境里实现的，一般称这个执行环境为虚拟机或执行引擎。

本文下面基于QuickJS这个Javascript的虚拟机，描述如何在虚拟机里实现in-line cache优化算法。首先介绍in-line cache的基本概念，然后介绍in-line cache实现的概要设计和详细设计，最后给出测试数据和结论。

<!-- more -->

## 基本概念

in-line cache优化是虚拟机中非常古老的技术，它最早是在Smalltalk编程语言的虚拟机上实现的。in-line cache的原理是利用局部性原理降低符号绑定的开销，对于同一个符号的访问，它会将前一次解析到的符号地址缓存到cache中。下次在访问该符号的时候只要简单校验下是否与上次访问该符号的条件相同（如类型是否相同），如果相同则直接使用cache中的地址，提高了访问效率；反之则需要重新查找符号地址并更新cache，会有cache访问失败的额外开销。如下图所示（图片来自【1】），左侧是没有inline-cache的虚拟机，每次读取一个数据的时候都需要到虚拟机里做符号查找等一些事情；右侧是有inline-cache的虚拟机，红线表示的是数据访问的快速路径，它可以省掉大部分虚拟机内部的复杂操作，直接获取数据。

![image-20250323120131010](./inline-cache-design/image-20250323120131010.png)

此外，in-line cache的in-line表示的是每条需要符号绑定的指令都会有一个对应的cache。一般的实现是生成一个stub函数来保存和访问这个cache，然后修改当前指令让其直接访问这个stub函数，这样子就类似于cache是直接放在当前指令上的，所以称为in-line（在指令行上）。与之对应的是lookup cache，它只将符号和对应的地址缓存在一个cache表里，没有关联对应的指令，使用的时候需要先根据符号在cache表中查找对应的cache位置，然后在应用cache到当前访问指令。因此，相比in-line cache，lookup cache会多一个在cache表中查找cache的开销，但是lookup cache的内存开销会低一点。

## in-line cache基础算法

in-line cache优化算法演进了很多了，在hotspot/V8这些成熟虚拟机中都有很完善的实现，这使得它可以发挥出强大的效果，不过也使得它变得很复杂晦涩难懂。为了便于理解，下面我们只介绍下基础算法，其它的in-line cache算法都基于此算法改进的，可以参考相关的实现或者论文。

in-line cache优化算法为了提高需要动态符号绑定的指令的执行效率，它会为每个需要动态符号绑定的指令提供了一个缓存。对于一个特定的指令的缓存可以用两个状态来描述，分别是无缓存状态和有缓存状态，有缓存状态下又可以分为缓存命中状态和缓存未命中状态。每个状态都有特定的处理过程，分别如下。

1. 无缓存状态下执行指令，会为当前指令执行默认的符号查找程序找到符号地址，并生成一个缓存绑定到当前指令；
2. 在有缓存状态下执行指令，会检验当前的参数信息（如类型）是否满足缓存的要求；
   - 如果满足则是缓存命中状态，直接使用缓存里的符号地址；
   - 如果不满足则是缓存未命中状态，执行默认的符号查找程序找到符号地址，并更新到缓存中。

在具体实现中，可以将无缓存状态当作缓存没命中状态处理，因此，它们可以共用一个处理子过程，而缓存命中状态使用另一个子过程。

## QuickJS 的in-line cache实现方案

QuickJS中没有为符号绑定的指令做优化，导致动态符号绑定指令增多时，其性能偏低。故而我们为其设计实现了in-line cache优化，期望可以提升其性能。

### 适用场景

为了降低实现难度，本次只针对对象属性的读写指令（如下程序）做了in-line cache优化，其它如函数调用、对象运算操作等也需要动态绑定的指令暂时没有支持。

```javascript
function getX(value) {
  return value.x;
}

function setX(value) {
  value.x = 2;
}
```

### 概要设计





## 总结

in-line cache利用局部性原理，通过缓存为动态绑定提供了一条快速路径，以低概率场景开销增加为代价换取高概率场景的效率提升。

## 参考

1. [Explaining JavaScript VMs in JavaScript - Inline Caches](https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)
2. 
