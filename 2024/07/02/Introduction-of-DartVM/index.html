<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Dart是Google在2011年10月10号发布的一种用于客户端（web或者移动应用）开发的编程语言，它是为了解决Javascript语言相关问题而设计。它有个基于VM思想实现的运行环境，即DartVM。本文通过阅读DartVM的早期代码和相关文章，了解DartVM的设计思路和整体框架结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction_of_DartVM">
<meta property="og:url" content="http://example.com/2024/07/02/Introduction-of-DartVM/index.html">
<meta property="og:site_name" content="Inside Compiler">
<meta property="og:description" content="Dart是Google在2011年10月10号发布的一种用于客户端（web或者移动应用）开发的编程语言，它是为了解决Javascript语言相关问题而设计。它有个基于VM思想实现的运行环境，即DartVM。本文通过阅读DartVM的早期代码和相关文章，了解DartVM的设计思路和整体框架结构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240705114904916.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240710152520269.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240710180804638.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240710224247728.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240710230723768.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/%E6%88%AA%E5%B1%8F2024-07-11%2000.01.35.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240805232427637.png">
<meta property="og:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240805235105089.png">
<meta property="article:published_time" content="2024-07-02T12:37:23.000Z">
<meta property="article:modified_time" content="2025-06-15T05:58:00.495Z">
<meta property="article:author" content="inside compiler">
<meta property="article:tag" content="DartVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/02/Introduction-of-DartVM/image-20240705114904916.png">


<link rel="canonical" href="http://example.com/2024/07/02/Introduction-of-DartVM/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/07/02/Introduction-of-DartVM/","path":"2024/07/02/Introduction-of-DartVM/","title":"Introduction_of_DartVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Introduction_of_DartVM | Inside Compiler</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Inside Compiler</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dart%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Dart语言简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DartVM%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text">DartVM整体框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E8%A7%84%E8%8C%83"><span class="nav-number">3.</span> <span class="nav-text">表示形式规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AST"><span class="nav-number">3.2.</span> <span class="nav-text">AST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.3.</span> <span class="nav-text">运行时表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">类型系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">堆内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">4.1.1.</span> <span class="nav-text">应用接口层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95%E5%B1%82"><span class="nav-number">4.1.2.</span> <span class="nav-text">内存管理算法层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">代码流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dart%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">Dart执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dart%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.1.</span> <span class="nav-text">Dart初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAIsolate"><span class="nav-number">5.1.2.</span> <span class="nav-text">创建Isolate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91"><span class="nav-number">5.1.3.</span> <span class="nav-text">函数代码编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.4.</span> <span class="nav-text">执行代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gen-snapshot%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">gen_snapshot执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="nav-number">5.3.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vm-isolate"><span class="nav-number">5.4.</span> <span class="nav-text">vm_isolate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7"><span class="nav-number">5.5.</span> <span class="nav-text">3.7</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-2"><span class="nav-number">6.1.</span> <span class="nav-text">内存管理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">inside compiler</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/02/Introduction-of-DartVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="inside compiler">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Inside Compiler">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Introduction_of_DartVM | Inside Compiler">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Introduction_of_DartVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-02 20:37:23" itemprop="dateCreated datePublished" datetime="2024-07-02T20:37:23+08:00">2024-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-15 13:58:00" itemprop="dateModified" datetime="2025-06-15T13:58:00+08:00">2025-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtual-machine/" itemprop="url" rel="index"><span itemprop="name">virtual machine</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Dart是Google在2011年10月10号发布的一种用于客户端（web或者移动应用）开发的编程语言，它是为了解决Javascript语言相关问题而设计。它有个基于VM思想实现的运行环境，即DartVM。本文通过阅读DartVM的早期代码和相关文章，了解DartVM的设计思路和整体框架结构。</p>
<span id="more"></span>

<h2 id="Dart语言简介"><a href="#Dart语言简介" class="headerlink" title="Dart语言简介"></a>Dart语言简介</h2><p>Dart是一种面向对象的语言，语法类似于C语言的语法，有C等编程语言基础的比较容易入门。</p>
<p>它基本类型如下。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>、<span class="built_in">double</span>、<span class="built_in">String</span>、<span class="built_in">bool</span>、<span class="built_in">List</span>、<span class="built_in">Map</span>、<span class="built_in">Set</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int x = 2;</span><br><span class="line">bool flag = true;</span><br><span class="line">String str = &quot;Dart&quot;;</span><br><span class="line"></span><br><span class="line">List list = new List(3);</span><br><span class="line">list[0] = &#x27;dart&#x27;;</span><br><span class="line"></span><br><span class="line">Map map = new Map();</span><br><span class="line">map[&#x27;F&#x27;] = &#x27;Dart&#x27;;</span><br></pre></td></tr></table></figure>

<p>Dart可以声明动态类型的变量，具体关键字如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var: 需要类型推导的变量；</span><br><span class="line">final：编译时确定类型；</span><br><span class="line">const：运行时确定类型；</span><br></pre></td></tr></table></figure>

<p>Dart语言的一些特性：</p>
<ol>
<li><p>可以通过“？”保证null安全，即变量没有标记“？”就是默认不为空的。</p>
</li>
<li><p>Dart里的Function也是一种Object，它有类型。</p>
</li>
<li><p>class里可以给属性定义Setter和Getter函数，用于获取和设置属性值。</p>
</li>
<li><p>具有异常处理机制。</p>
</li>
<li><p>并发机制。</p>
</li>
</ol>
<h2 id="DartVM整体框架"><a href="#DartVM整体框架" class="headerlink" title="DartVM整体框架"></a>DartVM整体框架</h2><p>DartVM早期代码量如下，总体上有71kLoc。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240705114904916.png" class="" title="image-20240705114904916">

<h2 id="表示形式规范"><a href="#表示形式规范" class="headerlink" title="表示形式规范"></a>表示形式规范</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>node类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/ast.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_LIST(V)                                                           \</span></span><br><span class="line"><span class="meta">  V(ReturnNode, <span class="string">&quot;return&quot;</span>)                                                      \</span></span><br><span class="line"><span class="meta">  V(LiteralNode, <span class="string">&quot;literal&quot;</span>)                                                    \</span></span><br><span class="line"><span class="meta">  V(TypeNode, <span class="string">&quot;type&quot;</span>)                                                          \</span></span><br><span class="line"><span class="meta">  V(BinaryOpNode, <span class="string">&quot;binop&quot;</span>)                                                     \</span></span><br><span class="line"><span class="meta">  V(StringConcatNode, <span class="string">&quot;concat&quot;</span>)                                                \</span></span><br><span class="line"><span class="meta">  V(ComparisonNode, <span class="string">&quot;compare&quot;</span>)                                                 \</span></span><br><span class="line"><span class="meta">  V(UnaryOpNode, <span class="string">&quot;unaryop&quot;</span>)                                                    \</span></span><br><span class="line"><span class="meta">  V(IncrOpLocalNode, <span class="string">&quot;incr local&quot;</span>)                                             \</span></span><br><span class="line"><span class="meta">  V(IncrOpInstanceFieldNode, <span class="string">&quot;incr instance field&quot;</span>)                            \</span></span><br><span class="line"><span class="meta">  V(IncrOpStaticFieldNode, <span class="string">&quot;incr static field&quot;</span>)                                \</span></span><br><span class="line"><span class="meta">  V(IncrOpIndexedNode, <span class="string">&quot;incr indexed&quot;</span>)                                         \</span></span><br><span class="line"><span class="meta">  V(ConditionalExprNode, <span class="string">&quot;?:&quot;</span>)                                                 \</span></span><br><span class="line"><span class="meta">  V(IfNode, <span class="string">&quot;if&quot;</span>)                                                              \</span></span><br><span class="line"><span class="meta">  V(SwitchNode, <span class="string">&quot;switch&quot;</span>)                                                      \</span></span><br><span class="line"><span class="meta">  V(CaseNode, <span class="string">&quot;case&quot;</span>)                                                          \</span></span><br><span class="line"><span class="meta">  V(WhileNode, <span class="string">&quot;while&quot;</span>)                                                        \</span></span><br><span class="line"><span class="meta">  V(DoWhileNode, <span class="string">&quot;dowhile&quot;</span>)                                                    \</span></span><br><span class="line"><span class="meta">  V(ForNode, <span class="string">&quot;for&quot;</span>)                                                            \</span></span><br><span class="line"><span class="meta">  V(JumpNode, <span class="string">&quot;jump&quot;</span>)                                                          \</span></span><br><span class="line"><span class="meta">  V(ArgumentListNode, <span class="string">&quot;args&quot;</span>)                                                  \</span></span><br><span class="line"><span class="meta">  V(ArrayNode, <span class="string">&quot;array&quot;</span>)                                                        \</span></span><br><span class="line"><span class="meta">  V(ClosureNode, <span class="string">&quot;closure&quot;</span>)                                                    \</span></span><br><span class="line"><span class="meta">  V(ImplicitClosureNode, <span class="string">&quot;implicit closure&quot;</span>)                                   \</span></span><br><span class="line"><span class="meta">  V(StaticImplicitClosureNode, <span class="string">&quot;static implicit closure&quot;</span>)                      \</span></span><br><span class="line"><span class="meta">  V(InstanceCallNode, <span class="string">&quot;instance call&quot;</span>)                                         \</span></span><br><span class="line"><span class="meta">  V(StaticCallNode, <span class="string">&quot;static call&quot;</span>)                                             \</span></span><br><span class="line"><span class="meta">  V(ClosureCallNode, <span class="string">&quot;closure call&quot;</span>)                                           \</span></span><br><span class="line"><span class="meta">  V(ConstructorCallNode, <span class="string">&quot;constructor call&quot;</span>)                                   \</span></span><br><span class="line"><span class="meta">  V(InstanceGetterNode, <span class="string">&quot;instance getter call&quot;</span>)                                \</span></span><br><span class="line"><span class="meta">  V(InstanceSetterNode, <span class="string">&quot;instance setter call&quot;</span>)                                \</span></span><br><span class="line"><span class="meta">  V(StaticGetterNode, <span class="string">&quot;static getter&quot;</span>)                                         \</span></span><br><span class="line"><span class="meta">  V(StaticSetterNode, <span class="string">&quot;static setter&quot;</span>)                                         \</span></span><br><span class="line"><span class="meta">  V(NativeBodyNode, <span class="string">&quot;native body&quot;</span>)                                             \</span></span><br><span class="line"><span class="meta">  V(PrimaryNode, <span class="string">&quot;primary&quot;</span>)                                                    \</span></span><br><span class="line"><span class="meta">  V(LoadLocalNode, <span class="string">&quot;load local&quot;</span>)                                               \</span></span><br><span class="line"><span class="meta">  V(StoreLocalNode, <span class="string">&quot;store local&quot;</span>)                                             \</span></span><br><span class="line"><span class="meta">  V(LoadInstanceFieldNode, <span class="string">&quot;load field&quot;</span>)                                       \</span></span><br><span class="line"><span class="meta">  V(StoreInstanceFieldNode, <span class="string">&quot;store field&quot;</span>)                                     \</span></span><br><span class="line"><span class="meta">  V(LoadStaticFieldNode, <span class="string">&quot;load static field&quot;</span>)                                  \</span></span><br><span class="line"><span class="meta">  V(StoreStaticFieldNode, <span class="string">&quot;store static field&quot;</span>)                                \</span></span><br><span class="line"><span class="meta">  V(LoadIndexedNode, <span class="string">&quot;load indexed&quot;</span>)                                           \</span></span><br><span class="line"><span class="meta">  V(StoreIndexedNode, <span class="string">&quot;store indexed&quot;</span>)                                         \</span></span><br><span class="line"><span class="meta">  V(SequenceNode, <span class="string">&quot;seq&quot;</span>)                                                       \</span></span><br><span class="line"><span class="meta">  V(CatchClauseNode, <span class="string">&quot;catch clause block&quot;</span>)                                     \</span></span><br><span class="line"><span class="meta">  V(TryCatchNode, <span class="string">&quot;try catch block&quot;</span>)                                           \</span></span><br><span class="line"><span class="meta">  V(ThrowNode, <span class="string">&quot;throw&quot;</span>)                                                        \</span></span><br><span class="line"><span class="meta">  V(InlinedFinallyNode, <span class="string">&quot;inlined finally&quot;</span>)                                     \</span></span><br></pre></td></tr></table></figure>

<h3 id="运行时表示"><a href="#运行时表示" class="headerlink" title="运行时表示"></a>运行时表示</h3><h4 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h4><p>共有49个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_LIST(V)                                                          \</span></span><br><span class="line"><span class="meta">  V(Object)                                                                    \</span></span><br><span class="line"><span class="meta">  CLASS_LIST_NO_OBJECT(V)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Macrobatics to define the Object hierarchy of VM implementation classes.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_LIST_NO_OBJECT(V)                                                \</span></span><br><span class="line"><span class="meta">  V(Class)                                                                     \</span></span><br><span class="line"><span class="meta">  V(Type)                                                                      \</span></span><br><span class="line"><span class="meta">    V(ParameterizedType)                                                       \</span></span><br><span class="line"><span class="meta">    V(TypeParameter)                                                           \</span></span><br><span class="line"><span class="meta">    V(InstantiatedType)                                                        \</span></span><br><span class="line"><span class="meta">  V(TypeArguments)                                                             \</span></span><br><span class="line"><span class="meta">    V(TypeArray)                                                               \</span></span><br><span class="line"><span class="meta">    V(InstantiatedTypeArguments)                                               \</span></span><br><span class="line"><span class="meta">  V(Function)                                                                  \</span></span><br><span class="line"><span class="meta">  V(Field)                                                                     \</span></span><br><span class="line"><span class="meta">  V(TokenStream)                                                               \</span></span><br><span class="line"><span class="meta">  V(Script)                                                                    \</span></span><br><span class="line"><span class="meta">  V(Library)                                                                   \</span></span><br><span class="line"><span class="meta">  V(LibraryPrefix)                                                             \</span></span><br><span class="line"><span class="meta">  V(Code)                                                                      \</span></span><br><span class="line"><span class="meta">  V(Instructions)                                                              \</span></span><br><span class="line"><span class="meta">  V(PcDescriptors)                                                             \</span></span><br><span class="line"><span class="meta">  V(ExceptionHandlers)                                                         \</span></span><br><span class="line"><span class="meta">  V(Context)                                                                   \</span></span><br><span class="line"><span class="meta">  V(ContextScope)                                                              \</span></span><br><span class="line"><span class="meta">  V(UnhandledException)                                                        \</span></span><br><span class="line"><span class="meta">  V(Instance)                                                                  \</span></span><br><span class="line"><span class="meta">    V(Number)                                                                  \</span></span><br><span class="line"><span class="meta">      V(Integer)                                                               \</span></span><br><span class="line"><span class="meta">        V(Smi)                                                                 \</span></span><br><span class="line"><span class="meta">        V(Mint)                                                                \</span></span><br><span class="line"><span class="meta">        V(Bigint)                                                              \</span></span><br><span class="line"><span class="meta">      V(Double)                                                                \</span></span><br><span class="line"><span class="meta">    V(String)                                                                  \</span></span><br><span class="line"><span class="meta">      V(OneByteString)                                                         \</span></span><br><span class="line"><span class="meta">      V(TwoByteString)                                                         \</span></span><br><span class="line"><span class="meta">      V(FourByteString)                                                        \</span></span><br><span class="line"><span class="meta">    V(Bool)                                                                    \</span></span><br><span class="line"><span class="meta">    V(Array)                                                                   \</span></span><br><span class="line"><span class="meta">      V(ImmutableArray)                                                        \</span></span><br><span class="line"><span class="meta">    V(Closure)                                                                 \</span></span><br><span class="line"><span class="meta">    V(Stacktrace)                                                              \</span></span><br><span class="line"><span class="meta">    V(JSRegExp)                                                                </span></span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h3><p>堆内存管理的整体架构图如下，分为三层。</p>
<ul>
<li>应用接口层：通过Heap给应用代码提供内存分配接口。</li>
<li>内存管理算法层：实现应用内存分配和回收功能，当前有两种实现分别是PageSpace和Scavenger。</li>
<li>系统适配层：通过VirtualMemory适配多个操作系统，实现向操作系统申请内存和释放内存等功能。</li>
</ul>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240710152520269.png" class="" title="image-20240710152520269">

<h4 id="应用接口层"><a href="#应用接口层" class="headerlink" title="应用接口层"></a>应用接口层</h4><p>应用接口层管理应用的堆内存，如内存空间初始化、内存分配等，这些功能都在Heap这个数据结构里。</p>
<p>在Heap里内存被划分成如下三个空间。</p>
<ul>
<li>New Space：存放生命周期比较短的数据，如String，BigInt，Context和ExceptHandle等。最大容量是32MB，使用Scavenger进行管理。</li>
<li>Old Space：存放生命周期长的数据，如Function、TokenStream等。最大容量是512MB，使用PageSpace进行管理。</li>
<li>Code Space：存放可执行的代码数据。最大容量是4MB，使用PageSpace进行管理。</li>
</ul>
<p>这个三个空间被标识为三种类型kNew、kOld和kExecutable。在Heap提供的内存分配接口中，它会根据请求的内存类型在上述对应的内存空间上进行分配，具体流程如下图所示，如果类型是kNew就在New Space里进行分配；而类型是kOld就在Old Space里进行分配；否则在Code Space里进行分配。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240710180804638.png" class="" title="image-20240710180804638">

<p>其中Old Space和Code Space如果没有内存空间进行分配就会报错，而New Space不会直接报错，它会先进行一次垃圾回收，然后在分配一次，如果还不行就在Old Space里进行分配。</p>
<h4 id="内存管理算法层"><a href="#内存管理算法层" class="headerlink" title="内存管理算法层"></a>内存管理算法层</h4><p>堆内存有两种算法实现–PageSpace和Scavenger。</p>
<p><strong>PageSpace</strong>不提前分配内存，而是每次内存不足的时候，按页进行内存申请再进行分配。分配得到的页是以链表的形式进行组织。这里的页分为两种，一种是大小固定的页（目前是256KB），一种是大小不固定的大页。因此，一个PageSpace里有两条页链表分别管理这两种内存页。如下图所示，pages表示的是固定页的链表，large pages表示的是大页的链表。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240710224247728.png" class="" title="image-20240710224247728">

<p>这两种页虽然大小是不同的，但是结构是相同的，都是由页头和数据空间组成。如下图所示，页头放的是一个由heapPage表示的页表元数据，里面主要是三个数据，即页的虚拟内存块元数据的地址、数据空间顶部地址和下一个页表地址；而数据空间就是存放数据，不过两种页存放的数据数量存在不同，固定页里会存放多个数据，而大页里只会存放一个数据。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240710230723768.png" class="" title="image-20240710230723768">

<p>下面我们介绍下PageSpace进行内存分配和内存回收的过程。</p>
<p>当应用向PageSpace管理的内存空间申请一块内存的时候，PageSpace就会进行内存分配，有以下4个步骤。</p>
<ol>
<li>根据申请的内存大小判断是否可以在固定页里分配；</li>
<li>如果申请的内存小于固定页的大小就按固定页进行分配；</li>
<li>否则按大页进行分配；</li>
<li>返回申请结果，地址或者0。</li>
</ol>
<p>固定页方式的内存分配过程如下。</p>
<ol>
<li><p>判断尾部页是否存在，以及剩余空间是否足够，如果尾部页不存在或者尾部页的剩余空间不够，则跳到第2步，否则跳到第3步；</p>
</li>
<li><p>申请新的固定页，使用尾插法，将其插到固定页链表的尾部，作为新的尾部页，如下图所示，新增的PageN是放在尾部的；</p>
<img src="/2024/07/02/Introduction-of-DartVM/%E6%88%AA%E5%B1%8F2024-07-11%2000.01.35.png" class="" title="截屏2024-07-11 00.01.35">
</li>
<li><p>在固定页里进行内存分配，此时使用的是Bump Allocation算法，即将数据空间顶部地址直接后移，得到所需的内存空间。</p>
</li>
</ol>
<p>大页的内存分配过程比较简单，它是按所需内存大小进行对齐后的结果直接申请一块大的内存块，然后将这个内存块按大页的形式插入到大页链表的头部进行管理（头插法，与固定页链表的插入方式不同，但从目前的实现来看，固定页链表的插入方式也是可以改成这种方式，可以节省一个尾指针的空间），最后再给到申请者这块内存的地址，供其使用。</p>
<p>PageSpace的内存回收比较简单，它是在PageSpace析构的时候直接释放所有内存。因此，不存在动态的垃圾回收过程。</p>
<p><strong>Scavenger</strong>使用了Cheney算法，是一种复制内存管理算法，它在初始化阶段会向系统申请了一段固定的内存，然后将内存均分为两个区间进行管理，如下图所示，在内存分配阶段会固定在一个区间里进行分配即分配区间，而另一个区间不做任何事情作为闲置区间。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240805232427637.png" class="" title="image-20240805232427637">

<p>当分配区间里无法分配内存了就会触发内存回收，在内存回收阶段会先依次检查分配区间里的每个数据是否存活（即是否还有存在的必要），并将存活的数据复制到闲置区间，最后释放分配区间里的数据并交换两个区间的角色。如下图所示，在经过一个分配和回收周期后，原有的分配区间变成闲置区间，而原有的闲置区间则变成分配区间。</p>
<img src="/2024/07/02/Introduction-of-DartVM/image-20240805235105089.png" class="" title="image-20240805235105089">

<p>在大部分的论文或者实现里，这两个内存区间会被称为分配区间&#x2F;幸存者区间（Allocation Space&#x2F;Survivor Space）或者From space&#x2F;To space。DartVM里采用的是From space&#x2F;To space这对名称来命名Scavenger的两个内存区间，下面我们将DartVM的Scavenger的实现分为初始化、内存分配和内存回收三个阶段分别进行介绍。</p>
<p>首先，在Scavenger初始化阶段，Scavenger就申请了32MB内存，并平均划分成From和To两个16MB空间（通过Memory Region进行管理）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Isolate</span> &#123;</span><br><span class="line">  Heap* heap_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="comment">// The different spaces used for allocation.</span></span><br><span class="line">  Scavenger* new_space_;</span><br><span class="line">  PageSpace* old_space_;</span><br><span class="line">  PageSpace* code_space_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RawObject类型只有属性和链表操作，Object只有成员函数和静态属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RawObject</span> &#123;</span><br><span class="line">  RawClass* class_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">  RawObject* raw_;  <span class="comment">// The raw object reference.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PageSpace</p>
<p>使用的是bump allocate算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/pages.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageSpace</span> &#123;</span><br><span class="line">  HeapPage* pages_;</span><br><span class="line">  HeapPage* pages_tail_;</span><br><span class="line">  HeapPage* large_pages_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分配内存时，如果内存空间不足就从虚拟内存中申请。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/pages.cc</span></span><br><span class="line"><span class="function">uword <span class="title">PageSpace::TryAllocate</span><span class="params">(<span class="type">intptr_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">AllocatePage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageSpace::AllocatePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HeapPage* page = HeapPage::<span class="built_in">Allocate</span>(kPageSize, is_executable_);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HeapPage* <span class="title">HeapPage::Allocate</span><span class="params">(<span class="type">intptr_t</span> size, <span class="type">bool</span> is_executable)</span> </span>&#123;</span><br><span class="line">  VirtualMemory* memory =</span><br><span class="line">      VirtualMemory::<span class="built_in">ReserveAligned</span>(size, PageSpace::kPageAlignment);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Initialize</span>(memory, is_executable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/virtual_memory.cc</span></span><br><span class="line"><span class="function">VirtualMemory* <span class="title">VirtualMemory::ReserveAligned</span><span class="params">(<span class="type">intptr_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">intptr_t</span> alignment)</span> </span>&#123;</span><br><span class="line">  VirtualMemory* result = VirtualMemory::<span class="built_in">Reserve</span>(size + alignment); </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>分配的内存也是通过memory region进行管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VirtualMemory* <span class="title">VirtualMemory::Reserve</span><span class="params">(<span class="type">intptr_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span>* address = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_RESERVE, PAGE_NOACCESS);</span><br><span class="line">  <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">MemoryRegion <span class="title">region</span><span class="params">(address, size)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VirtualMemory</span>(region, address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scavenger</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/scavenger.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scavenger</span> &#123;</span><br><span class="line">  VirtualMemory* space_;</span><br><span class="line">  MemoryRegion* to_;</span><br><span class="line">  MemoryRegion* from_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Scavenger在构造函数阶段就会申请内存，并平均分为to和from两个半区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Scavenger::<span class="built_in">Scavenger</span>(Heap* heap, <span class="type">intptr_t</span> max_capacity, uword object_alignment)</span><br><span class="line">    : <span class="built_in">heap_</span>(heap),</span><br><span class="line">      <span class="built_in">object_alignment_</span>(object_alignment),</span><br><span class="line">      <span class="built_in">count_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">scavenging_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// Allocate the virtual memory for this scavenge heap.</span></span><br><span class="line">  space_ = VirtualMemory::<span class="built_in">Reserve</span>(max_capacity);</span><br><span class="line">        </span><br><span class="line">  <span class="comment">// Setup the semi spaces.</span></span><br><span class="line">  uword semi_space_size = space_-&gt;<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">  to_ = <span class="keyword">new</span> <span class="built_in">MemoryRegion</span>(space_-&gt;<span class="built_in">address</span>(), semi_space_size);</span><br><span class="line">  uword middle = space_-&gt;<span class="built_in">start</span>() + semi_space_size;</span><br><span class="line">  from_ = <span class="keyword">new</span> <span class="built_in">MemoryRegion</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(middle), semi_space_size);        </span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p>在heap使用new space分配不出内存时，会触发new space的内存回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uword <span class="title">Heap::AllocateNew</span><span class="params">(<span class="type">intptr_t</span> size)</span> </span>&#123;</span><br><span class="line">  new_space_-&gt;<span class="built_in">Scavenge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个回收过程由4部分组成，并且有个迭代器进行指针遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scavenger::Scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup the visitor and run a scavenge.</span></span><br><span class="line">  <span class="function">ScavengerVisitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="built_in">Prologue</span>();</span><br><span class="line">  <span class="built_in">IterateRoots</span>(&amp;visitor);</span><br><span class="line">  <span class="built_in">ProcessToSpace</span>(&amp;visitor);</span><br><span class="line">  <span class="built_in">Epilogue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为对象一开始是分配在to空间的，所以在前期阶段主要是交换from和to指针，为后面的from空间到to空间的对象拷贝做准备。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scavenger::Prologue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Flip the two semi-spaces so that to_ is always the space for allocating</span></span><br><span class="line">  <span class="comment">// objects.</span></span><br><span class="line">  MemoryRegion* temp = from_;</span><br><span class="line">  from_ = to_;</span><br><span class="line">  to_ = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Isolate、old space和code space这三者包含的子object开始遍历（即它们三者包含的object是Roots），如果object是from space的，就拷贝到to space中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scavenger::IterateRoots</span><span class="params">(ObjectPointerVisitor* visitor)</span> </span>&#123;</span><br><span class="line">  Isolate::<span class="built_in">Current</span>()-&gt;<span class="built_in">VisitObjectPointers</span>(</span><br><span class="line">      visitor, StackFrameIterator::kDontValidateFrames);</span><br><span class="line">  heap_-&gt;<span class="built_in">IterateOldPointers</span>(visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历to space object的class object和field object，如果object是from space的，就拷贝到to space中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScavengerVisitor</span> : <span class="keyword">public</span> ObjectPointerVisitor &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">VisitPointers</span><span class="params">(RawObject** first, RawObject** last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RawObject** current = first; current &lt;= last; current++) &#123;</span><br><span class="line">      <span class="built_in">ScavengePointer</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，如果object不是堆上的object或者它不在from space就不需要处理直接返回。然后，通过kForwarded标志判断object是否已经处理过了，如果处理过就直接返回；否则，就申请to space空间，拷贝，并将旧指针置为新指针和kForwarded标志或之后的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScavengerVisitor</span> : <span class="keyword">public</span> ObjectPointerVisitor &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ScavengePointer</span><span class="params">(RawObject** p)</span> </span>&#123;</span><br><span class="line">    RawObject* raw_obj = *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast exit if the raw object is a Smi.</span></span><br><span class="line">    <span class="keyword">if</span> (!raw_obj-&gt;<span class="built_in">IsHeapObject</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    uword raw_addr = RawObject::<span class="built_in">ToAddr</span>(raw_obj);</span><br><span class="line">    <span class="comment">// Objects should be contained in the heap.</span></span><br><span class="line">    <span class="comment">// TODO(iposva): Add an appropriate assert here or in the return block</span></span><br><span class="line">    <span class="comment">// below.</span></span><br><span class="line">    <span class="comment">// The scavenger is only interested in objects located in the from space.</span></span><br><span class="line">    <span class="keyword">if</span> (!scavenger_-&gt;from_-&gt;<span class="built_in">Contains</span>(raw_addr)) &#123;</span><br><span class="line">      <span class="comment">// Addresses being visited cannot point in the to space. As this would</span></span><br><span class="line">      <span class="comment">// either mean the pointer is being visited twice or this pointer has not</span></span><br><span class="line">      <span class="comment">// been evacuated during the last scavenge. Both of these situations are</span></span><br><span class="line">      <span class="comment">// an error.</span></span><br><span class="line">      <span class="built_in">ASSERT</span>(!scavenger_-&gt;to_-&gt;<span class="built_in">Contains</span>(raw_addr));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><h3 id="Dart执行过程"><a href="#Dart执行过程" class="headerlink" title="Dart执行过程"></a>Dart执行过程</h3><p>主流程里有</p>
<ol>
<li>参数解析</li>
<li>DartVM初始化</li>
<li>isolate创建</li>
<li>进入scope（独立的handle管理和内存分配）</li>
<li>dart文件编译</li>
<li>dart库链接</li>
<li>dart文件执行（从main开始）</li>
<li>执行结果处理</li>
<li>退出scope</li>
<li>消息循环执行</li>
<li>profiler符号记录</li>
<li>isolate关闭</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ParseArguments</span>(argc, argv, &amp;vm_options, &amp;script_name, &amp;dart_options);</span><br><span class="line">  <span class="built_in">Dart_Initialize</span>(vm_options.<span class="built_in">count</span>(), vm_options.<span class="built_in">arguments</span>(), MainIsolateInitCallback);</span><br><span class="line">  Dart_Isolate isolate = <span class="built_in">Dart_CreateIsolate</span>(snapshot_buffer, script_name);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Dart_EnterScope</span>();</span><br><span class="line">  <span class="built_in">Dart_CompileAll</span>();</span><br><span class="line">  Dart_Handle script_url = <span class="built_in">Dart_NewString</span>(script_name);</span><br><span class="line">  Dart_Result result = <span class="built_in">Dart_LookupLibrary</span>(script_url);</span><br><span class="line">  </span><br><span class="line">  Dart_Handle library = <span class="built_in">Dart_GetResult</span>(result);</span><br><span class="line">  result = <span class="built_in">Dart_InvokeStatic</span>(library,</span><br><span class="line">                             <span class="built_in">Dart_NewString</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">                             <span class="built_in">Dart_NewString</span>(<span class="string">&quot;main&quot;</span>),</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             <span class="literal">NULL</span>);</span><br><span class="line">  Dart_Handle result_obj = <span class="built_in">Dart_GetResult</span>(result);</span><br><span class="line">  <span class="built_in">Dart_ExitScope</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Dart_RunLoop</span>();</span><br><span class="line">  <span class="built_in">DumpPprofSymbolInfo</span>();</span><br><span class="line">  <span class="built_in">Dart_ShutdownIsolate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dart初始化"><a href="#Dart初始化" class="headerlink" title="Dart初始化"></a>Dart初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(iposva): This is a placeholder for the eventual external Dart API.</span></span><br><span class="line"><span class="function">DART_EXPORT <span class="type">bool</span> <span class="title">Dart_Initialize</span><span class="params">(<span class="type">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">char</span>** argv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Dart_IsolateInitCallback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Dart::<span class="built_in">InitOnce</span>(argc, argv, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>OS初始化，设置了一个标志位，用于防止重复初始化；</li>
<li>虚拟内存初始化，获取内存页的大小；</li>
<li>Isolate初始化，创建线程key；</li>
<li>创建vm isolate并初始化；</li>
<li>将Isoalte::Current置空；</li>
<li>设置初始化回调函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/dart.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dart::InitOnce</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Dart_IsolateInitCallback callback)</span> </span>&#123;</span><br><span class="line">  OS::<span class="built_in">InitOnce</span>();</span><br><span class="line">  VirtualMemory::<span class="built_in">InitOnce</span>();</span><br><span class="line">  Isolate::<span class="built_in">InitOnce</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create the VM isolate and finish the VM initialization.</span></span><br><span class="line">  &#123; .. &#125;</span><br><span class="line">  </span><br><span class="line">  Isolate::<span class="built_in">SetCurrent</span>(<span class="literal">NULL</span>);  <span class="comment">// Unregister the VM isolate from this thread.</span></span><br><span class="line">  Isolate::<span class="built_in">SetInitCallback</span>(callback);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>创建vm isolate并初始化：</p>
<ol>
<li>新建一个vm_isolate;</li>
<li>初始化新Heap;</li>
<li>初始化新ObjectStore；</li>
<li>初始化Object；</li>
<li>初始化stub_code，生成stub_code代码；</li>
<li>初始化PortMap；</li>
<li>初始化Scanner；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/dart.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dart::InitOnce</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv,</span></span></span><br><span class="line"><span class="params"><span class="function">                    Dart_IsolateInitCallback callback)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// Create the VM isolate and finish the VM initialization.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ASSERT</span>(vm_isolate_ == <span class="literal">NULL</span>);</span><br><span class="line">    vm_isolate_ = Isolate::<span class="built_in">Init</span>();</span><br><span class="line">    Zone zone;</span><br><span class="line">    HandleScope handle_scope;</span><br><span class="line">    Heap::<span class="built_in">Init</span>(vm_isolate_);</span><br><span class="line">    ObjectStore::<span class="built_in">Init</span>(vm_isolate_);</span><br><span class="line">    Object::<span class="built_in">InitOnce</span>();</span><br><span class="line">    StubCode::<span class="built_in">InitOnce</span>();</span><br><span class="line">    PortMap::<span class="built_in">InitOnce</span>();</span><br><span class="line">    Scanner::<span class="built_in">InitOnce</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/object.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Object::InitOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/stub_code.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StubCode::InitOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PortMap::InitOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建Isolate"><a href="#创建Isolate" class="headerlink" title="创建Isolate"></a>创建Isolate</h4><p>其中Object可以直接初始化，也可以来自snapshot。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/dart_api_impl.cc</span></span><br><span class="line"><span class="function">DART_EXPORT Dart_Isolate <span class="title">Dart_CreateIsolate</span><span class="params">(<span class="type">void</span>* snapshot, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = Dart::<span class="built_in">CreateIsolate</span>(snapshot, data);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Dart_Isolate&gt;(isolate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Isolate* <span class="title">Dart::CreateIsolate</span><span class="params">(<span class="type">void</span>* snapshot_buffer, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create and initialize a new isolate.</span></span><br><span class="line">  Isolate* isolate = Isolate::<span class="built_in">Init</span>();</span><br><span class="line">  Zone zone;</span><br><span class="line">  HandleScope handle_scope;</span><br><span class="line">  Heap::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  ObjectStore::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  <span class="keyword">if</span> (snapshot_buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    Object::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize from snapshot (this should replicate the functionality</span></span><br><span class="line">    <span class="comment">// of Object::Init(..) in a regular isolate creation path.</span></span><br><span class="line">    Object::<span class="built_in">InitFromSnapshot</span>(isolate);</span><br><span class="line">    Snapshot* snapshot = Snapshot::<span class="built_in">SetupFromBuffer</span>(snapshot_buffer);</span><br><span class="line">    <span class="function">SnapshotReader <span class="title">reader</span><span class="params">(snapshot, isolate-&gt;heap(), isolate-&gt;object_store())</span></span>;</span><br><span class="line">    reader.<span class="built_in">ReadFullSnapshot</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StubCode::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  CodeIndexTable::<span class="built_in">Init</span>(isolate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give the embedder a shot at setting up this isolate.</span></span><br><span class="line">  <span class="comment">// Isolates spawned from within this isolate will be given the callback data</span></span><br><span class="line">  <span class="comment">// returned by the callback.</span></span><br><span class="line">  data = Isolate::<span class="built_in">InitCallback</span>()(data);</span><br><span class="line">  <span class="comment">// TODO(iposva): Shutdown the isolate on failure.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">set_init_callback_data</span>(data);</span><br><span class="line">  <span class="keyword">return</span> isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CodeIndexTable初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/code_index_table.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeIndexTable::Init</span><span class="params">(Isolate* isolate)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ASSERT</span>(isolate-&gt;<span class="built_in">code_index_table</span>() == <span class="literal">NULL</span>);</span><br><span class="line">  CodeIndexTable* code_index_table = <span class="keyword">new</span> <span class="built_in">CodeIndexTable</span>();</span><br><span class="line">  isolate-&gt;<span class="built_in">set_code_index_table</span>(code_index_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>dart文件加载；</li>
<li>核心库加载；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">MainIsolateInitCallback</span><span class="params">(<span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">  result = <span class="built_in">LoadScript</span>(script_name);</span><br><span class="line">  Dart_Handle library = <span class="built_in">Dart_GetResult</span>(result);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Builtin_ImportLibrary</span>(library);</span><br><span class="line">  <span class="comment">// Setup the native resolver for built in library functions.</span></span><br><span class="line">  <span class="built_in">Builtin_SetNativeResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/bin/process_script.cc</span></span><br><span class="line"><span class="function">Dart_Result <span class="title">LoadScript</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* script_name)</span> </span>&#123;</span><br><span class="line">  Dart_Result result = <span class="built_in">ReadStringFromFile</span>(script_name);</span><br><span class="line">  Dart_Handle source = <span class="built_in">Dart_GetResult</span>(result);</span><br><span class="line">  Dart_Handle url = <span class="built_in">Dart_NewString</span>(script_name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Dart_LoadScript</span>(url, source, LibraryTagHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将代码以字符串的形式读到内存中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Dart_Result <span class="title">ReadStringFromFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">  File* file = File::<span class="built_in">OpenFile</span>(filename, <span class="literal">false</span>);</span><br><span class="line">  <span class="type">intptr_t</span> len = file-&gt;<span class="built_in">Length</span>();</span><br><span class="line">  <span class="type">char</span>* text_buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(<span class="built_in">malloc</span>(len + <span class="number">1</span>));</span><br><span class="line">  file-&gt;<span class="built_in">ReadFully</span>(text_buffer, len);</span><br><span class="line">  Dart_Handle str = <span class="built_in">Dart_NewString</span>(text_buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Dart_ResultAsObject</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成Library</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DART_EXPORT Dart_Result <span class="title">Dart_LoadScript</span><span class="params">(Dart_Handle url,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Dart_Handle source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Dart_LibraryTagHandler handler)</span> </span>&#123;</span><br><span class="line">  isolate-&gt;<span class="built_in">set_library_tag_handler</span>(handler);</span><br><span class="line">  library = Library::<span class="built_in">New</span>(url_str);</span><br><span class="line">  library.<span class="built_in">Register</span>();</span><br><span class="line">  Dart_Result result;</span><br><span class="line">  <span class="built_in">CompileSource</span>(library, url_str, source_str, RawScript::kScript, &amp;result);</span><br><span class="line">  <span class="keyword">return</span> result;  </span><br><span class="line">&#125;                                        </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/parser.cc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CompileSource</span><span class="params">(<span class="type">const</span> Library&amp; lib,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> String&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> String&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RawScript::Kind kind,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Dart_Result* result)</span> </span>&#123;</span><br><span class="line">  Compiler::<span class="built_in">Compile</span>(lib, script);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compiler::Compile</span><span class="params">(<span class="type">const</span> Library&amp; library, <span class="type">const</span> Script&amp; script)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> String&amp; library_key = String::<span class="built_in">Handle</span>(library.<span class="built_in">private_key</span>());</span><br><span class="line">  script.<span class="built_in">Tokenize</span>(library_key);</span><br><span class="line">  Parser::<span class="built_in">ParseCompilationUnit</span>(library, script);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/parser.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::ParseCompilationUnit</span><span class="params">(<span class="type">const</span> Library&amp; library,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> Script&amp; script)</span> </span>&#123;</span><br><span class="line">  <span class="function">Parser <span class="title">parser</span><span class="params">(script, library)</span></span>;</span><br><span class="line">  parser.<span class="built_in">ParseTopLevel</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::ParseTopLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">set_current_class</span>(Class::<span class="built_in">Handle</span>());  <span class="comment">// No current class.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CurrentToken</span>() == Token::kCLASS) &#123;</span><br><span class="line">      <span class="built_in">ParseClassDefinition</span>(&amp;classes);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CurrentToken</span>() == Token::kTYPEDEF) &#123;</span><br><span class="line">      <span class="built_in">ParseFunctionTypeAlias</span>(&amp;classes);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CurrentToken</span>() == Token::kINTERFACE) &#123;</span><br><span class="line">      <span class="built_in">ParseInterfaceDefinition</span>(&amp;classes);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsVariableDeclaration</span>()) &#123;</span><br><span class="line">      <span class="built_in">set_current_class</span>(toplevel_class);</span><br><span class="line">      <span class="built_in">ParseTopLevelVariable</span>(&amp;top_level);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsTopLevelFunction</span>()) &#123;</span><br><span class="line">      <span class="built_in">set_current_class</span>(toplevel_class);</span><br><span class="line">      <span class="built_in">ParseTopLevelFunction</span>(&amp;top_level);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsTopLevelAccessor</span>()) &#123;</span><br><span class="line">      <span class="built_in">set_current_class</span>(toplevel_class);</span><br><span class="line">      <span class="built_in">ParseTopLevelAccessor</span>(&amp;top_level);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CurrentToken</span>() == Token::kEOS) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">UnexpectedToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                            </span><br></pre></td></tr></table></figure>

<h4 id="函数代码编译"><a href="#函数代码编译" class="headerlink" title="函数代码编译"></a>函数代码编译</h4><p>编译Dart代码，依次遍历每个库文件，在每个库文件里依次编译class中的函数和匿名class中的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/dart_api_impl.cc</span></span><br><span class="line"><span class="function">DART_EXPORT Dart_Result <span class="title">Dart_CompileAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CompileAll</span>(&amp;result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/object.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Library::CompileAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Library&amp; lib = Library::<span class="built_in">Handle</span>(</span><br><span class="line">      Isolate::<span class="built_in">Current</span>()-&gt;<span class="built_in">object_store</span>()-&gt;<span class="built_in">registered_libraries</span>());</span><br><span class="line">  Class&amp; cls = Class::<span class="built_in">Handle</span>();</span><br><span class="line">  <span class="keyword">while</span> (!lib.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">    <span class="function">ClassDictionaryIterator <span class="title">it</span><span class="params">(lib)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (it.<span class="built_in">HasNext</span>()) &#123;</span><br><span class="line">      Compiler::<span class="built_in">CompileAllFunctions</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Array&amp; anon_classes = Array::<span class="built_in">Handle</span>(lib.<span class="built_in">raw_ptr</span>()-&gt;anonymous_classes_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lib.<span class="built_in">raw_ptr</span>()-&gt;num_anonymous_; i++) &#123;</span><br><span class="line">      Compiler::<span class="built_in">CompileAllFunctions</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    lib = lib.<span class="built_in">next_registered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/compiler.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compiler::CompileAllFunctions</span><span class="params">(<span class="type">const</span> Class&amp; cls)</span> </span>&#123;</span><br><span class="line">  Array&amp; functions = Array::<span class="built_in">Handle</span>(cls.<span class="built_in">functions</span>());</span><br><span class="line">  Function&amp; func = Function::<span class="built_in">Handle</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; functions.<span class="built_in">Length</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">CompileFunction</span>(func);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compiler::CompileFunction</span><span class="params">(<span class="type">const</span> Function&amp; function)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CompileFunctionHelper</span>(function, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三种编译过程：</p>
<ol>
<li><p>首次编译，直接会编译成未优化代码；</p>
</li>
<li><p>在有未优化代码的情况下，编译成优化代码；</p>
<p>这个场景下会根据退优化的次数判断是否使用类型反馈信息。</p>
</li>
<li><p>将优化代码切换成未优化代码。</p>
</li>
</ol>
<p>编译完成后，函数指针会被添加到CodeIndexTable中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CompileFunctionHelper</span><span class="params">(<span class="type">const</span> Function&amp; function, <span class="type">bool</span> optimized)</span> </span>&#123;</span><br><span class="line">  <span class="function">ParsedFunction <span class="title">parsed_function</span><span class="params">(function)</span></span>;</span><br><span class="line">  Parser::<span class="built_in">ParseFunction</span>(&amp;parsed_function);</span><br><span class="line">  CodeIndexTable* code_index_table = Isolate::<span class="built_in">Current</span>()-&gt;<span class="built_in">code_index_table</span>();</span><br><span class="line">  Assembler assembler;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (optimized) &#123;</span><br><span class="line">    <span class="built_in">ExtractTypeFeedback</span>(Code::<span class="built_in">Handle</span>(parsed_function.<span class="built_in">function</span>().<span class="built_in">code</span>()),  </span><br><span class="line">                        parsed_function.<span class="built_in">node_sequence</span>());  </span><br><span class="line">    <span class="function">OptimizingCodeGenerator <span class="title">code_gen</span><span class="params">(&amp;assembler, parsed_function)</span></span>;</span><br><span class="line">    code_gen.<span class="built_in">GenerateCode</span>();</span><br><span class="line">    function.<span class="built_in">SetCode</span>(code);</span><br><span class="line">    code_index_table-&gt;<span class="built_in">AddFunction</span>(function);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Unoptimized code.</span></span><br><span class="line">    <span class="keyword">if</span> (Code::<span class="built_in">Handle</span>(function.<span class="built_in">unoptimized_code</span>()).<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">      <span class="built_in">ASSERT</span>(Code::<span class="built_in">Handle</span>(function.<span class="built_in">code</span>()).<span class="built_in">IsNull</span>());</span><br><span class="line">      <span class="comment">// Compiling first time.</span></span><br><span class="line">      <span class="function">CodeGenerator <span class="title">code_gen</span><span class="params">(&amp;assembler, parsed_function)</span></span>;</span><br><span class="line">      code_gen.<span class="built_in">GenerateCode</span>();</span><br><span class="line">      function.<span class="built_in">SetCode</span>(code);</span><br><span class="line">      code_index_table-&gt;<span class="built_in">AddFunction</span>(function);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Disable optimized code.</span></span><br><span class="line">      <span class="type">const</span> Code&amp; optimized_code = Code::<span class="built_in">Handle</span>(function.<span class="built_in">code</span>());</span><br><span class="line">      <span class="built_in">ASSERT</span>(optimized_code.<span class="built_in">is_optimized</span>());</span><br><span class="line">      CodePatcher::<span class="built_in">PatchEntry</span>(Code::<span class="built_in">Handle</span>(function.<span class="built_in">code</span>()));</span><br><span class="line">      <span class="comment">// Use previously compiled code.</span></span><br><span class="line">      function.<span class="built_in">SetCode</span>(Code::<span class="built_in">Handle</span>(function.<span class="built_in">unoptimized_code</span>()));</span><br><span class="line">      CodePatcher::<span class="built_in">RestoreEntry</span>(Code::<span class="built_in">Handle</span>(function.<span class="built_in">unoptimized_code</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parser is at the opening parenthesis of the formal parameter declaration</span></span><br><span class="line"><span class="comment">// of function. Parse the formal parameters and code.</span></span><br><span class="line"><span class="function">SequenceNode* <span class="title">Parser::ParseFunc</span><span class="params">(<span class="type">const</span> Function&amp; func,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Array&amp; default_parameter_values)</span> </span>&#123;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>不优化的CodeGen–CodeGenerator。</p>
<p>通过宏隔离区分不同Target的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TARGET_ARCH_IA32</span><br><span class="line">TARGET_ARCH_ARM</span><br><span class="line">TARGET_ARCH_X64</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> First 5 bytes of the code may be patched with a jump instruction. Do</span></span><br><span class="line"><span class="comment">// not emit any objects in the first 5 bytes.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::GenerateCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GeneratePreEntryCode</span>();</span><br><span class="line">  <span class="built_in">GenerateEntryCode</span>();</span><br><span class="line">  parsed_function_.<span class="built_in">node_sequence</span>()-&gt;<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">GenerateDeferredCode</span>();</span><br><span class="line">  pc_descriptors_list_-&gt;<span class="built_in">AddDescriptor</span>(PcDescriptors::kPatchCode,</span><br><span class="line">                                      assembler_-&gt;<span class="built_in">CodeSize</span>(),</span><br><span class="line">                                      AstNode::kInvalidId,</span><br><span class="line">                                      <span class="number">0</span>,</span><br><span class="line">                                      <span class="number">-1</span>);</span><br><span class="line">  <span class="function">__ <span class="title">jmp</span><span class="params">(&amp;StubCode::FixCallersTargetLabel())</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数进入前的栈溢出检查和调用次数上报（用于后续的优化等级提升），此外，当允许优化的时候跳到优化代码上去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pre entry code is called before the frame has been constructed:</span></span><br><span class="line"><span class="comment">// - check for stack overflow.</span></span><br><span class="line"><span class="comment">// - optionally count function invocations.</span></span><br><span class="line"><span class="comment">// - optionally trigger optimizing compiler if invocation threshold has been</span></span><br><span class="line"><span class="comment">//   reached.</span></span><br><span class="line"><span class="comment">// Note that first 5 bytes may be patched with a jump.</span></span><br><span class="line"><span class="comment">// TODO(srdjan): Add check that no object is inlined in the first</span></span><br><span class="line"><span class="comment">// 5 bytes (length of a jump instruction).</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::GeneratePreEntryCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (may_optimize) &#123;</span><br><span class="line">    <span class="function">__ <span class="title">cmpl</span><span class="params">(EBX, Immediate(FLAG_optimization_invocation_threshold))</span></span>;</span><br><span class="line">    <span class="function">__ <span class="title">j</span><span class="params">(GREATER, &amp;StubCode::OptimizeInvokedFunctionLabel())</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈帧创建和参数处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call to generate entry code:</span></span><br><span class="line"><span class="comment">// - compute frame size and setup frame.</span></span><br><span class="line"><span class="comment">// - allocate local variables on stack.</span></span><br><span class="line"><span class="comment">// - optionally check if number of arguments match.</span></span><br><span class="line"><span class="comment">// - initialize all non-argument locals to null.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Input parameters:</span></span><br><span class="line"><span class="comment">//   ESP : points to return address.</span></span><br><span class="line"><span class="comment">//   ESP + 4 : address of last argument (arg n-1).</span></span><br><span class="line"><span class="comment">//   ESP + 4*n : address of first argument (arg 0).</span></span><br><span class="line"><span class="comment">//   EDX : arguments descriptor array.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::GenerateEntryCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历节点进行指令生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_VISIT_FUNCTION(type, name)                                      \</span></span><br><span class="line"><span class="meta">  void type::Visit(AstNodeVisitor* visitor) &#123;                                  \</span></span><br><span class="line"><span class="meta">    visitor-&gt;Visit##type(this);                                                \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="built_in">NODE_LIST</span>(DEFINE_VISIT_FUNCTION)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DEFINE_VISIT_FUNCTION</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/code_generator_ia32.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::VisitSequenceNode</span><span class="params">(SequenceNode* node_sequence)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::VisitLoadLocalNode</span><span class="params">(LoadLocalNode* node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Load the value of the local variable and push it onto the expression stack.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsResultNeeded</span>(node)) &#123;</span><br><span class="line">    <span class="built_in">GeneratePushVariable</span>(node-&gt;<span class="built_in">local</span>(), EAX);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">oid <span class="title">CodeGenerator::GeneratePushVariable</span><span class="params">(<span class="type">const</span> LocalVariable&amp; variable,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Register scratch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (variable.<span class="built_in">is_captured</span>()) &#123;</span><br><span class="line">    <span class="comment">// The variable lives in the context.</span></span><br><span class="line">    <span class="type">int</span> delta = <span class="built_in">state</span>()-&gt;<span class="built_in">context_level</span>() - variable.<span class="built_in">owner</span>()-&gt;<span class="built_in">context_level</span>();</span><br><span class="line">    <span class="built_in">ASSERT</span>(delta &gt;= <span class="number">0</span>);</span><br><span class="line">    Register base = CTX;</span><br><span class="line">    <span class="keyword">while</span> (delta-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="function">__ <span class="title">movl</span><span class="params">(scratch, FieldAddress(base, Context::parent_offset()))</span></span>;</span><br><span class="line">      base = scratch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__ <span class="title">pushl</span><span class="params">(FieldAddress(base, Context::variable_offset(variable.index())))</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The variable lives in the current stack frame.</span></span><br><span class="line">    __ <span class="built_in">pushl</span>(<span class="built_in">Address</span>(EBP, variable.<span class="built_in">index</span>() * kWordSize));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用object成员函数的时候就会用到inline cache和deopt功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::VisitInstanceCallNode</span><span class="params">(InstanceCallNode* node)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> number_of_arguments = node-&gt;<span class="built_in">arguments</span>()-&gt;<span class="built_in">length</span>() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Compute the receiver object and pass it as first argument to call.</span></span><br><span class="line">  node-&gt;<span class="built_in">receiver</span>()-&gt;<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// Now compute rest of the arguments to the call.</span></span><br><span class="line">  node-&gt;<span class="built_in">arguments</span>()-&gt;<span class="built_in">Visit</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// Some method may be inlined using type feedback, therefore this may be a</span></span><br><span class="line">  <span class="comment">// deoptimization point.</span></span><br><span class="line">  <span class="built_in">MarkDeoptPoint</span>(node-&gt;<span class="built_in">id</span>(), node-&gt;<span class="built_in">token_index</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GenerateInstanceCall</span>(node-&gt;<span class="built_in">id</span>(),</span><br><span class="line">                       node-&gt;<span class="built_in">token_index</span>(),</span><br><span class="line">                       node-&gt;<span class="built_in">function_name</span>(),</span><br><span class="line">                       number_of_arguments,</span><br><span class="line">                       node-&gt;<span class="built_in">arguments</span>());</span><br><span class="line">  <span class="comment">// Result is in EAX.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsResultNeeded</span>(node)) &#123;</span><br><span class="line">    <span class="function">__ <span class="title">pushl</span><span class="params">(EAX)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inline cache调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenerator::GenerateInstanceCall</span><span class="params">(<span class="type">intptr_t</span> node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">intptr_t</span> token_index,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> String&amp; function_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int</span> arg_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         ArgumentListNode* arguments)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Set up the function name and number of arguments (including the receiver)</span></span><br><span class="line">  <span class="comment">// to the InstanceCall stub which will resolve the correct entrypoint for</span></span><br><span class="line">  <span class="comment">// the operator and call it.</span></span><br><span class="line">  <span class="function">__ <span class="title">LoadObject</span><span class="params">(ECX, function_name)</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">LoadObject</span><span class="params">(EDX, ArgumentsDescriptor(arg_count, arguments))</span></span>;</span><br><span class="line">  <span class="function">__ <span class="title">call</span><span class="params">(&amp;StubCode::CallInstanceFunctionLabel())</span></span>;</span><br><span class="line">  <span class="built_in">AddCurrentDescriptor</span>(PcDescriptors::kIcCall,</span><br><span class="line">                       node_id,</span><br><span class="line">                       token_index);</span><br><span class="line">  <span class="function">__ <span class="title">addl</span><span class="params">(ESP, Immediate(arg_count * kWordSize))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StubCode::GenerateCallInstanceFunctionStub</span><span class="params">(Assembler* assembler)</span> </span>&#123;</span><br><span class="line">  <span class="function">__ <span class="title">CallRuntimeFromStub</span><span class="params">(kResolvePatchInstanceCallRuntimeEntry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resolve instance call and patch it to jump to IC stub or megamorphic stub.</span></span><br><span class="line"><span class="comment">// After patching the caller&#x27;s instance call instruction, that call will</span></span><br><span class="line"><span class="comment">// be reexecuted and ran through the created IC stub. The null receivers</span></span><br><span class="line"><span class="comment">// have special handling, i.e., they lead to megamorphic lookup that implements</span></span><br><span class="line"><span class="comment">// the appropriate null behavior.</span></span><br><span class="line"><span class="comment">//   Arg0: receiver object.</span></span><br><span class="line"><span class="built_in">DEFINE_RUNTIME_ENTRY</span>(ResolvePatchInstanceCall, <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="type">const</span> Instance&amp; receiver = Instance::<span class="built_in">CheckedHandle</span>(arguments.<span class="built_in">At</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="type">const</span> Code&amp; code = Code::<span class="built_in">Handle</span>(<span class="built_in">ResolveCompileInstanceCallTarget</span>(receiver));</span><br><span class="line">  DartFrameIterator iterator;</span><br><span class="line">  DartFrame* caller_frame = iterator.<span class="built_in">NextFrame</span>();</span><br><span class="line">  String&amp; function_name = String::<span class="built_in">Handle</span>();</span><br><span class="line">  <span class="keyword">if</span> ((!receiver.<span class="built_in">IsNull</span>() &amp;&amp; code.<span class="built_in">IsNull</span>()) || !FLAG_inline_cache) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CodePatcher::<span class="built_in">GetInstanceCallAt</span>(caller_frame-&gt;<span class="built_in">pc</span>(),</span><br><span class="line">                                   &amp;function_name,</span><br><span class="line">                                   &amp;num_arguments,</span><br><span class="line">                                   &amp;num_named_arguments,</span><br><span class="line">                                   &amp;caller_target);</span><br><span class="line">    <span class="comment">// If caller_target is not in CallInstanceFunction stub (resolve call)</span></span><br><span class="line">    <span class="comment">// then it must be pointing to an IC stub.</span></span><br><span class="line">    <span class="type">const</span> Class&amp; receiver_class = Class::<span class="built_in">ZoneHandle</span>(receiver.<span class="built_in">clazz</span>());    </span><br><span class="line">    <span class="type">const</span> Code&amp; ic_code = Code::<span class="built_in">Handle</span>(ICStubs::<span class="built_in">GetICStub</span>(classes, targets));</span><br><span class="line">    CodePatcher::<span class="built_in">PatchInstanceCallAt</span>(caller_frame-&gt;<span class="built_in">pc</span>(), ic_code.<span class="built_in">EntryPoint</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/code_patcher_ia32.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodePatcher::GetInstanceCallAt</span><span class="params">(uword return_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    String* function_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">int</span>* num_arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">int</span>* num_named_arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    uword* target)</span> </span>&#123;</span><br><span class="line">  <span class="function">InstanceCall <span class="title">call</span><span class="params">(return_address)</span></span>;</span><br><span class="line">  *num_arguments = call.<span class="built_in">argument_count</span>();</span><br><span class="line">  *num_named_arguments = call.<span class="built_in">named_argument_count</span>();</span><br><span class="line">  *target = call.<span class="built_in">target</span>();</span><br><span class="line">  *function_name = call.<span class="built_in">function_name</span>();  </span><br><span class="line">&#125;                                    </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/ic_stubs_ia32.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate inline cache stub for given targets and classes.</span></span><br><span class="line"><span class="comment">//  EDX: arguments descriptor array (preserved).</span></span><br><span class="line"><span class="comment">//  ECX: function name (unused, preserved).</span></span><br><span class="line"><span class="comment">//  TOS: return address.</span></span><br><span class="line"><span class="comment">// Jump to target if the receiver&#x27;s class matches the &#x27;receiver_class&#x27;.</span></span><br><span class="line"><span class="comment">// Otherwise jump to megamorphic lookup. TODO(srdjan): Patch call site to go to</span></span><br><span class="line"><span class="comment">// megamorphic instead of going via the IC stub.</span></span><br><span class="line"><span class="comment">// IC stub structure:</span></span><br><span class="line"><span class="comment">//   A: Get receiver, test if Smi, jump to IC miss or hit.</span></span><br><span class="line"><span class="comment">//   B: Get receiver&#x27;s class, compare with all known classes.</span></span><br><span class="line"><span class="function">RawCode* <span class="title">ICStubs::GetICStub</span><span class="params">(<span class="type">const</span> GrowableArray&lt;<span class="type">const</span> Class*&gt;&amp; classes,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> GrowableArray&lt;<span class="type">const</span> Function*&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;                            </span><br></pre></td></tr></table></figure>

<p>优化代码生成器–OptimizingCodeGenerator</p>
<p>继承自CodeGenerator，在一些Node实现上进行扩展，生成更高效的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OptimizingCodeGenerator::VisitLoadLocalNode</span><span class="params">(LoadLocalNode* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsResultNeeded</span>(node)) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsResultInEaxRequested</span>(node)) &#123;</span><br><span class="line">    <span class="built_in">GenerateLoadVariable</span>(EAX, node-&gt;<span class="built_in">local</span>());</span><br><span class="line">    node-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">set_result_returned_in_eax</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">GeneratePushVariable</span>(node-&gt;<span class="built_in">local</span>(), EAX);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在优化生成器中会有退优化的操作。首先是生成检查点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(srdjan): Expand inline caches to detect Smi/double operations, so that</span></span><br><span class="line"><span class="comment">// we do not have to call the instance method, and therefore could guarantee</span></span><br><span class="line"><span class="comment">// that the result is a Smi at the end.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OptimizingCodeGenerator::GenerateSmiBinaryOp</span><span class="params">(BinaryOpNode* node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (left_info.<span class="built_in">IsClass</span>(smi_class_) || right_info.<span class="built_in">IsClass</span>(smi_class_)) &#123;</span><br><span class="line">     DeoptimizationBlob* deopt_blob = <span class="built_in">AddDeoptimizationBlob</span>(node, EAX, EDX);</span><br><span class="line">     overflow_label = deopt_blob-&gt;<span class="built_in">label</span>();</span><br><span class="line">     <span class="function">__ <span class="title">movl</span><span class="params">(ECX, EAX)</span></span>;  <span class="comment">// Save if overflow (needs original value).</span></span><br><span class="line">     <span class="keyword">if</span> (!left_info.<span class="built_in">IsClass</span>(smi_class_) || !right_info.<span class="built_in">IsClass</span>(smi_class_)) &#123;</span><br><span class="line">       Register test_reg = left_info.<span class="built_in">IsClass</span>(smi_class_) ? EDX : EAX;</span><br><span class="line">       <span class="function">__ <span class="title">testl</span><span class="params">(test_reg, Immediate(kSmiTagMask))</span></span>;</span><br><span class="line">       <span class="function">__ <span class="title">j</span><span class="params">(NOT_ZERO, deopt_blob-&gt;label())</span></span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在生成退优化代码，即DeferredCode。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OptimizingCodeGenerator::GenerateDeferredCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CodeGenerator::<span class="built_in">GenerateDeferredCode</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deoptimization_blobs_.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    deoptimization_blobs_[i]-&gt;<span class="built_in">Generate</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code that calls the deoptimizer, emitted as deferred code (out of line).</span></span><br><span class="line"><span class="comment">// Specify the corresponding &#x27;node&#x27; and the registers that need to</span></span><br><span class="line"><span class="comment">// be pushed for the deoptimization point in unoptimized code.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeoptimizationBlob</span> : <span class="keyword">public</span> ZoneAllocated &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Generate</span><span class="params">(OptimizingCodeGenerator* codegen)</span> </span>&#123;</span><br><span class="line">    codegen-&gt;<span class="built_in">assembler</span>()-&gt;<span class="built_in">Bind</span>(&amp;label_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; registers_.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">      codegen-&gt;<span class="built_in">assembler</span>()-&gt;<span class="built_in">pushl</span>(registers_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    codegen-&gt;<span class="built_in">CallDeoptimize</span>(node_-&gt;<span class="built_in">id</span>(), node_-&gt;<span class="built_in">token_index</span>());</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OptimizingCodeGenerator::CallDeoptimize</span><span class="params">(<span class="type">intptr_t</span> node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">intptr_t</span> token_index)</span> </span>&#123;</span><br><span class="line">  <span class="function">__ <span class="title">call</span><span class="params">(&amp;StubCode::DeoptimizeLabel())</span></span>;</span><br><span class="line">  <span class="built_in">AddCurrentDescriptor</span>(PcDescriptors::kOther, node_id, token_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><ol>
<li>从函数库中加载函数地址；</li>
<li>设置参数；</li>
<li>调用函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DART_EXPORT Dart_Result <span class="title">Dart_InvokeStatic</span><span class="params">(Dart_Handle library_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Dart_Handle class_name_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Dart_Handle function_name_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">int</span> number_of_arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Dart_Handle* arguments)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Function&amp; function = Function::<span class="built_in">Handle</span>(</span><br><span class="line">    Resolver::<span class="built_in">ResolveStatic</span>(library,</span><br><span class="line">                            class_name,</span><br><span class="line">                            function_name,</span><br><span class="line">                            number_of_arguments,</span><br><span class="line">                            Array::<span class="built_in">Handle</span>(),  <span class="comment">// Named arguments are not yet</span></span><br><span class="line">                                              <span class="comment">// supported in the API.</span></span><br><span class="line">                            Resolver::kIsQualified));</span><br><span class="line">  </span><br><span class="line">  <span class="function">GrowableArray&lt;<span class="type">const</span> Object*&gt; <span class="title">dart_arguments</span><span class="params">(number_of_arguments)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number_of_arguments; i++) &#123;</span><br><span class="line">    <span class="type">const</span> Object&amp; arg = Object::<span class="built_in">Handle</span>(Api::<span class="built_in">UnwrapHandle</span>(arguments[i]));</span><br><span class="line">    dart_arguments.<span class="built_in">Add</span>(&amp;arg);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">InvokeStatic</span>(function, dart_arguments, &amp;retval);</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure>

<p>动态链接，有两种场景。</p>
<ol>
<li>全局函数链接；</li>
<li>class中静态成员函数链接；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/resolver.cc</span></span><br><span class="line"><span class="function">RawFunction* <span class="title">Resolver::ResolveStatic</span><span class="params">(<span class="type">const</span> Library&amp; library,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> String&amp; class_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> String&amp; function_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">int</span> num_arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> Array&amp; argument_names,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StaticResolveType resolve_type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (class_name.<span class="built_in">IsNull</span>() || (class_name.<span class="built_in">Length</span>() == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Check if we are referring to a top level function.</span></span><br><span class="line">    <span class="type">const</span> Object&amp; object = Object::<span class="built_in">Handle</span>(library.<span class="built_in">LookupObject</span>(function_name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Lookup class_name in the library&#x27;s class dictionary to get at</span></span><br><span class="line">    <span class="comment">// the dart class object. If class_name is not found in the dictionary</span></span><br><span class="line">    <span class="comment">// ResolveStatic will return a NULL function object.</span></span><br><span class="line">    <span class="type">const</span> Class&amp; cls = Class::<span class="built_in">Handle</span>(library.<span class="built_in">LookupClass</span>(class_name));</span><br><span class="line">    function = <span class="built_in">ResolveStatic</span>(cls,</span><br><span class="line">                             function_name,</span><br><span class="line">                             num_arguments,</span><br><span class="line">                             argument_names,</span><br><span class="line">                             resolve_type); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> function.<span class="built_in">raw</span>();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>先在当前库中查找符号，找不到在遍历import的库进行查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RawObject* <span class="title">Library::LookupObject</span><span class="params">(<span class="type">const</span> String&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  Object&amp; obj = Object::<span class="built_in">Handle</span>(<span class="built_in">LookupLocalObject</span>(name));</span><br><span class="line">  <span class="keyword">if</span> (!obj.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">raw</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  Library&amp; <span class="keyword">import</span> = Library::<span class="built_in">Handle</span>();</span><br><span class="line">  Array&amp; imports = Array::<span class="built_in">Handle</span>(<span class="keyword">this</span>-&gt;<span class="built_in">imports</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">intptr_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">num_imports</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">import</span> ^= imports.<span class="built_in">At</span>(i);</span><br><span class="line">    obj = <span class="keyword">import</span>.<span class="built_in">LookupLocalObject</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">raw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Object::<span class="built_in">null</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Library的字典中查找函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RawObject* <span class="title">Library::LookupLocalObject</span><span class="params">(<span class="type">const</span> String&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Array&amp; dict = Array::<span class="built_in">Handle</span>(<span class="built_in">dictionary</span>());</span><br><span class="line">  <span class="type">intptr_t</span> dict_size = dict.<span class="built_in">Length</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="type">intptr_t</span> index = name.<span class="built_in">Hash</span>() % dict_size;</span><br><span class="line">  </span><br><span class="line">  entry = dict.<span class="built_in">At</span>(index);</span><br><span class="line">  <span class="comment">// Search the entry in the hash set.</span></span><br><span class="line">  <span class="keyword">while</span> (!entry.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="built_in">IsFunction</span>()) &#123;</span><br><span class="line">      func ^= entry.<span class="built_in">raw</span>();</span><br><span class="line">      entry_name = func.<span class="built_in">name</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry_name.<span class="built_in">Equals</span>(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> entry.<span class="built_in">raw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    index = (index + <span class="number">1</span>) % dict_size;</span><br><span class="line">    entry = dict.<span class="built_in">At</span>(index);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>调用函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Need to pass &#x27;result&#x27; as a parameter here in order to avoid</span></span><br><span class="line"><span class="comment">// warning: variable &#x27;result&#x27; might be clobbered by &#x27;longjmp&#x27; or &#x27;vfork&#x27;</span></span><br><span class="line"><span class="comment">// which shows up because of the use of setjmp.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InvokeStatic</span><span class="params">(<span class="type">const</span> Function&amp; function,</span></span></span><br><span class="line"><span class="params"><span class="function">                         GrowableArray&lt;<span class="type">const</span> Object*&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Dart_Result* result)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Instance&amp; retval = Instance::<span class="built_in">Handle</span>(DartEntry::<span class="built_in">InvokeStatic</span>(function, args));</span><br><span class="line">  result-&gt;type_ = kRetObject;</span><br><span class="line">  result-&gt;retval_.obj_value = Api::<span class="built_in">NewLocalHandle</span>(retval);  </span><br><span class="line">&#125;                         </span><br></pre></td></tr></table></figure>

<p>首先，如果函数还没有汇编代码，则会先调用编译接口进行编译。然后，获取stub函数和执行上下文。最后，调用函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/dart_entry.cc</span></span><br><span class="line"><span class="function">RawInstance* <span class="title">DartEntry::InvokeStatic</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Function&amp; function, <span class="type">const</span> GrowableArray&lt;<span class="type">const</span> Object*&gt;&amp; arguments)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get the entrypoint corresponding to the function specified, this</span></span><br><span class="line">  <span class="comment">// will result in a compilation of the function if it is not already</span></span><br><span class="line">  <span class="comment">// compiled.</span></span><br><span class="line">  <span class="keyword">if</span> (!function.<span class="built_in">HasCode</span>()) &#123;</span><br><span class="line">    Compiler::<span class="built_in">CompileFunction</span>(function);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">const</span> Code&amp; code = Code::<span class="built_in">Handle</span>(function.<span class="built_in">code</span>());</span><br><span class="line">  <span class="type">const</span> Instructions&amp; instrs = Instructions::<span class="built_in">Handle</span>(code.<span class="built_in">instructions</span>());</span><br><span class="line">  <span class="comment">// Now Call the invoke stub which will invoke the dart function.</span></span><br><span class="line">  invokestub entrypoint = <span class="built_in">reinterpret_cast</span>&lt;invokestub&gt;(</span><br><span class="line">      StubCode::<span class="built_in">InvokeDartCodeEntryPoint</span>());</span><br><span class="line">  <span class="type">const</span> Context&amp; context =</span><br><span class="line">      Context::<span class="built_in">ZoneHandle</span>(Isolate::<span class="built_in">Current</span>()-&gt;<span class="built_in">object_store</span>()-&gt;<span class="built_in">empty_context</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">entrypoint</span>(</span><br><span class="line">      instrs.<span class="built_in">EntryPoint</span>(),</span><br><span class="line">      CodeGenerator::<span class="built_in">ArgumentsDescriptor</span>(arguments.<span class="built_in">length</span>(), <span class="literal">NULL</span>),</span><br><span class="line">      arguments.<span class="built_in">data</span>(),</span><br><span class="line">      context);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>stub</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/vm/stub_code.h</span></span><br><span class="line"><span class="comment">// List of stubs created per isolate, these stubs could potentially contain</span></span><br><span class="line"><span class="comment">// embedded objects and hence cannot be shared across isolates.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUB_CODE_LIST(V)                                                      \</span></span><br><span class="line"><span class="meta">  V(InvokeDartCode)                                                            \</span></span><br><span class="line"><span class="meta">  V(AllocateContext)                                                           \</span></span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="comment">// class StubCode is used to maintain the lifecycle of stubs.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StubCode</span> &#123;</span><br><span class="line">  <span class="comment">// Define the per-isolate stub code accessors.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUB_CODE_ACCESSOR(name)                                               \</span></span><br><span class="line"><span class="meta">  static StubEntry* name##_entry() &#123;                                           \</span></span><br><span class="line"><span class="meta">    return Isolate::Current()-&gt;stub_code()-&gt;name##_entry_;                     \</span></span><br><span class="line"><span class="meta">  &#125;                                                                            \</span></span><br><span class="line"><span class="meta">  static uword name##EntryPoint() &#123;                                            \</span></span><br><span class="line"><span class="meta">    return name##_entry()-&gt;EntryPoint();                                       \</span></span><br><span class="line"><span class="meta">  &#125;                                                                            \</span></span><br><span class="line"><span class="meta">  static intptr_t name##Size() &#123;                                               \</span></span><br><span class="line"><span class="meta">    return name##_entry()-&gt;Size();                                             \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">  <span class="built_in">STUB_CODE_LIST</span>(STUB_CODE_ACCESSOR);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STUB_CODE_ACCESSOR  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when invoking dart code from C++ (VM code).</span></span><br><span class="line"><span class="comment">// Input parameters:</span></span><br><span class="line"><span class="comment">//   ESP : points to return address.</span></span><br><span class="line"><span class="comment">//   ESP + 4 : entrypoint of the dart function to call.</span></span><br><span class="line"><span class="comment">//   ESP + 8 : arguments descriptor array.</span></span><br><span class="line"><span class="comment">//   ESP + 12 : pointer to the argument array.</span></span><br><span class="line"><span class="comment">//   ESP + 16 : new context containing the current isolate pointer.</span></span><br><span class="line"><span class="comment">// Uses EAX, EDX, ECX, EDI as temporary registers.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StubCode::GenerateInvokeDartCodeStub</span><span class="params">(Assembler* assembler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Call the dart code entrypoint.</span></span><br><span class="line">  <span class="function">__ <span class="title">call</span><span class="params">(Address(EBP, kEntryPointOffset))</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gen-snapshot执行过程"><a href="#gen-snapshot执行过程" class="headerlink" title="gen_snapshot执行过程"></a>gen_snapshot执行过程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the Dart VM.</span></span><br><span class="line">  <span class="built_in">Dart_Initialize</span>(vm_options.<span class="built_in">count</span>(),</span><br><span class="line">                  vm_options.<span class="built_in">arguments</span>(),</span><br><span class="line">                  SnapshotCreateCallback);</span><br><span class="line">                  </span><br><span class="line">  <span class="comment">// Create an isolate. As a side effect, SnapshotCreateCallback</span></span><br><span class="line">  <span class="comment">// gets called, which loads the script (if one is specified), its libraries</span></span><br><span class="line">  <span class="comment">// and writes out a snapshot.</span></span><br><span class="line">  Dart_Isolate isolate = <span class="built_in">Dart_CreateIsolate</span>(<span class="literal">NULL</span>, script_name);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Shutdown the isolate.</span></span><br><span class="line">  <span class="built_in">Dart_ShutdownIsolate</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行环境初始化，然后调用回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DART_EXPORT Dart_Isolate <span class="title">Dart_CreateIsolate</span><span class="params">(<span class="type">void</span>* snapshot, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create and initialize a new isolate.</span></span><br><span class="line">  Isolate* isolate = Isolate::<span class="built_in">Init</span>();</span><br><span class="line">  Zone zone;</span><br><span class="line">  HandleScope handle_scope;</span><br><span class="line">  Heap::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  ObjectStore::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  Object::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  StubCode::<span class="built_in">Init</span>(isolate);</span><br><span class="line">  CodeIndexTable::<span class="built_in">Init</span>(isolate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give the embedder a shot at setting up this isolate.</span></span><br><span class="line">  <span class="comment">// Isolates spawned from within this isolate will be given the callback data</span></span><br><span class="line">  <span class="comment">// returned by the callback.</span></span><br><span class="line">  data = Isolate::<span class="built_in">InitCallback</span>()(data);</span><br><span class="line">  <span class="comment">// TODO(iposva): Shutdown the isolate on failure.</span></span><br><span class="line">  isolate-&gt;<span class="built_in">set_init_callback_data</span>(data);</span><br><span class="line">  <span class="keyword">return</span> isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/bin/gen_snapshot.cc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">SnapshotCreateCallback</span><span class="params">(<span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* script_name = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data)</span><br><span class="line">  <span class="built_in">Dart_EnterScope</span>();</span><br><span class="line">  result = <span class="built_in">LoadScript</span>(script_name);</span><br><span class="line">  Dart_Handle library = <span class="built_in">Dart_GetResult</span>(result);</span><br><span class="line">  <span class="built_in">Builtin_ImportLibrary</span>(library);</span><br><span class="line">  <span class="comment">// Setup the native resolver for built in library functions.</span></span><br><span class="line">  <span class="built_in">Builtin_SetNativeResolver</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// First create the snapshot.</span></span><br><span class="line">  result = <span class="built_in">Dart_CreateSnapshot</span>(&amp;buffer, &amp;size);  </span><br><span class="line">  <span class="comment">// Now write the snapshot out to specified file and exit.</span></span><br><span class="line">  <span class="built_in">WriteSnapshotFile</span>(buffer, size);</span><br><span class="line">  <span class="built_in">Dart_ExitScope</span>();</span><br><span class="line">  <span class="keyword">return</span> data;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DART_EXPORT Dart_Result <span class="title">Dart_CreateSnapshot</span><span class="params">(<span class="type">uint8_t</span>** snapshot_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">intptr_t</span>* snapshot_size)</span> </span>&#123;</span><br><span class="line">&#125;                                            </span><br></pre></td></tr></table></figure>

<h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><p>Heap分为三个区，New，Old和Code。其中，New使用Scavenger进行管理，Old和Code使用PageSpace进行管理。</p>
<p>使用的是<strong>Cheney’s algorithm</strong>（Copy GC）。</p>
<p>在申请内存的时候，发现没有空间则进行GC。如果GC之后还没有内存空间，则尝试从老生代进行分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uword <span class="title">Heap::AllocateNew</span><span class="params">(<span class="type">intptr_t</span> size)</span> </span>&#123;</span><br><span class="line">  uword addr = new_space_-&gt;<span class="built_in">TryAllocate</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  new_space_-&gt;<span class="built_in">Scavenge</span>();</span><br><span class="line"> </span><br><span class="line">  addr = new_space_-&gt;<span class="built_in">TryAllocate</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateOld</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scavenger::Scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Setup the visitor and run a scavenge.</span></span><br><span class="line">  <span class="function">ScavengerVisitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="built_in">Prologue</span>();</span><br><span class="line">  <span class="built_in">IterateRoots</span>(&amp;visitor);</span><br><span class="line">  <span class="built_in">ProcessToSpace</span>(&amp;visitor);</span><br><span class="line">  <span class="built_in">Epilogue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vm-isolate"><a href="#vm-isolate" class="headerlink" title="vm_isolate"></a>vm_isolate</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the non-GC&#x27;d Dart::vm_isolate_.</span><br></pre></td></tr></table></figure>

<h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">enum class GCType &#123;</span><br><span class="line">  kScavenge,</span><br><span class="line">  kEvacuate,</span><br><span class="line">  kStartConcurrentMark,</span><br><span class="line">  kMarkSweep,</span><br><span class="line">  kMarkCompact,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum class GCReason &#123;</span><br><span class="line">  kNewSpace,     // New space is full.</span><br><span class="line">  kStoreBuffer,  // Store buffer is too big.</span><br><span class="line">  kPromotion,    // Old space limit crossed after a scavenge.</span><br><span class="line">  kOldSpace,     // Old space limit crossed, or old space allocation failed.</span><br><span class="line">  kFinalize,     // Concurrent marking finished.</span><br><span class="line">  kFull,         // Heap::CollectAllGarbage</span><br><span class="line">  kExternal,     // Dart_NewFinalizableHandle Dart_NewWeakPersistentHandle</span><br><span class="line">  kIdle,         // Dart_NotifyIdle</span><br><span class="line">  kDestroyed,    // Dart_NotifyDestroyed</span><br><span class="line">  kDebugging,    // service request, etc.</span><br><span class="line">  kCatchUp,      // End of ForceGrowthScope or Dart_PerformanceMode_Latency.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/@author2000.1225/the-history-and-rules-of-dart-language-f25e09a58530">https://medium.com/@author2000.1225/the-history-and-rules-of-dart-language-f25e09a58530</a></li>
<li><a target="_blank" rel="noopener" href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html</a></li>
</ol>
<h3 id="内存管理-2"><a href="#内存管理-2" class="headerlink" title="内存管理"></a>内存管理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1879916">https://cloud.tencent.com/developer/article/1879916</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7036005463946690590">https://juejin.cn/post/7036005463946690590</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/DartVM/" rel="tag"># DartVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/15/mlir-interfaces/" rel="prev" title="第4章（3）：接口">
                  <i class="fa fa-angle-left"></i> 第4章（3）：接口
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/08/03/mlir-pass/" rel="next" title="第5章：Pass和Passmanager">
                  第5章：Pass和Passmanager <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">inside compiler</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"inside-compiler","repo":"inside-compiler.github.io","client_id":"3b662fd9edd646229c79","client_secret":"312a2514c4029a47341087757f0c051786144c77","admin_user":"fiking","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"labels":["gitalk"],"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"432c479d9053c3031d1563e81c5ef8e4"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
