<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第3章类型、属性、操作和方言详解第2章简单介绍了MLIR基础知识，本章将详细介绍MLIR方言、操作、类型和属性相关知识。操作是MLIR中最基础的概念，变换、转换、分析等都是针对操作进行；类型用于修饰操作；属性可以修饰操作和方言，为操作和方言提供额外的信息；方言用于管理类型、属性和操作元数据（方言管理的类型和属性都是对象，原因是类型和属性都是全局唯一；但是操作可以多次示例化多个操作对象，所以方言并不">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章：类型、属性、操作和方言详解">
<meta property="og:url" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/index.html">
<meta property="og:site_name" content="Inside Compiler">
<meta property="og:description" content="第3章类型、属性、操作和方言详解第2章简单介绍了MLIR基础知识，本章将详细介绍MLIR方言、操作、类型和属性相关知识。操作是MLIR中最基础的概念，变换、转换、分析等都是针对操作进行；类型用于修饰操作；属性可以修饰操作和方言，为操作和方言提供额外的信息；方言用于管理类型、属性和操作元数据（方言管理的类型和属性都是对象，原因是类型和属性都是全局唯一；但是操作可以多次示例化多个操作对象，所以方言并不">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256960800154.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969190851.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969369644.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969557877.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256971083934.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17161092896495.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256977135851.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256978084756.jpg">
<meta property="og:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256978666317.jpg">
<meta property="article:published_time" content="2024-05-19T08:47:37.000Z">
<meta property="article:modified_time" content="2025-06-15T05:58:00.498Z">
<meta property="article:author" content="inside compiler">
<meta property="article:tag" content="MLIR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256960800154.jpg">


<link rel="canonical" href="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/","path":"2024/05/19/MLIR-Dialect-Op-Type-Attr/","title":"第3章：类型、属性、操作和方言详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>第3章：类型、属性、操作和方言详解 | Inside Compiler</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Inside Compiler</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0%E7%B1%BB%E5%9E%8B%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%B9%E8%A8%80%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">第3章类型、属性、操作和方言详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">3.1类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">3.1.1类型定义和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TD%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">TD定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8ETD%E5%88%B0%E8%AE%B0%E5%BD%95"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">从TD到记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%AE%B0%E5%BD%95%E5%88%B0C-%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">从记录到C++代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%B1%BB%E5%9E%8B%E5%88%B0%E6%96%B9%E8%A8%80%E4%B8%AD"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">注册类型到方言中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2%E7%B1%BB%E5%9E%8B%E6%96%87%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.1.2类型文法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">类型使用和类型对象创建过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">3.2属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1%E5%B1%9E%E6%80%A7%EF%BC%88Attribute%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">3.2.1属性（Attribute）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">属性文法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2%E7%89%B9%E6%80%A7%EF%BC%88Property%EF%BC%89"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.2.2特性（Property）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">3.3操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1%E6%93%8D%E4%BD%9C%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.3.1操作定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%AE%9A%E4%B9%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">操作定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TD%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">TD定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8ETD%E5%88%B0%E8%AE%B0%E5%BD%95-1"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">从TD到记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%AE%B0%E5%BD%95%E5%88%B0C-%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">从记录到C++代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%93%8D%E4%BD%9C%E5%88%B0%E6%96%B9%E8%A8%80%E4%B8%AD"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">注册操作到方言中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3.2操作内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3%E6%93%8D%E4%BD%9C%E6%96%87%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.3.3操作文法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4%E6%96%B9%E8%A8%80"><span class="nav-number">1.4.</span> <span class="nav-text">3.4方言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1%E6%96%B9%E8%A8%80%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.4.1方言定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TD%E5%AE%9A%E4%B9%89-2"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">TD定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8ETD%E5%88%B0%E8%AE%B0%E5%BD%95-2"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">从TD到记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TD%E5%88%B0C-%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">TD到C++代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E8%A8%80%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">方言接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2%E6%89%A9%E5%B1%95%E6%96%B9%E8%A8%80"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.4.2扩展方言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3%E6%96%B9%E8%A8%80%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C%E3%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.4.3方言管理操作、类型和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4%E6%96%B9%E8%A8%80%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%86%85%E5%BB%BA%E6%96%B9%E8%A8%80"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.4.4方言示例：内建方言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5%E7%BC%96%E8%AF%91%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">3.5编译上下文管理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">inside compiler</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/19/MLIR-Dialect-Op-Type-Attr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="inside compiler">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Inside Compiler">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="第3章：类型、属性、操作和方言详解 | Inside Compiler">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第3章：类型、属性、操作和方言详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-19 16:47:37" itemprop="dateCreated datePublished" datetime="2024-05-19T16:47:37+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-15 13:58:00" itemprop="dateModified" datetime="2025-06-15T13:58:00+08:00">2025-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MLIR/" itemprop="url" rel="index"><span itemprop="name">MLIR</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第3章类型、属性、操作和方言详解"><a href="#第3章类型、属性、操作和方言详解" class="headerlink" title="第3章类型、属性、操作和方言详解"></a>第3章类型、属性、操作和方言详解</h1><p>第2章简单介绍了MLIR基础知识，本章将详细介绍MLIR方言、操作、类型和属性相关知识。操作是MLIR中最基础的概念，变换、转换、分析等都是针对操作进行；类型用于修饰操作；属性可以修饰操作和方言，为操作和方言提供额外的信息；方言用于管理类型、属性和操作元数据（方言管理的类型和属性都是对象，原因是类型和属性都是全局唯一；但是操作可以多次示例化多个操作对象，所以方言并不直接管理操作对象，而是管理操作的元数据）。本章最后会介绍MLIR框架提供的MLIRContext，它用于管理各种方言，开发者通过MLIRContext可以访问方言、从而访问类型和属性以及操作元数据（并可以通过操作元数据示例化操作对象）。下面逐一介绍类型、属性、操作和方言。</p>
<h2 id="3-1类型"><a href="#3-1类型" class="headerlink" title="3.1类型"></a>3.1类型</h2><p>在MLIR中类型作用于操作，例如操作的结果、操作中的操作数、基本块参数等都是有类型的。类型可以分为两类：内建类型（Built-in type）和自定义类型。内建类型是MLIR提供的常见类型，例如BFloat16、Integer、Complex、Vector、RankedTensor、UnRankedTensor、MemRef等，开发者可以直接使用内建类型。当内建类型无法满足开发者需要时，开发者可以自定义类型，对于自定义类型MLIR框架并未提供显式的约束，所以开发者可以任意定义需要的类型。对于内建类型，MLIR框架会负责类型的降级（例如从MLIR世界进入到LLVM世界时，MLIR会统一将内建类型转换为LLVM IR能够接受的类型）；对于自定义类型，开发者需要在方言降级时进行类型的降级，否则可能会出错（无法成功降级）。<br>我们知道在一个系统中类型通常都是唯一的（类型可以看作是操作对象的约束，多个操作共享同一种类型约束，所以一个类型只需要示例化对象即可；当操作的约束不同时，应该使用不同的类型描述），类型对象通常存在方言中。本质上类型就是C++的类，当使用类型时就是示例化一个C++类的对象。</p>
<h3 id="3-1-1类型定义和使用"><a href="#3-1-1类型定义和使用" class="headerlink" title="3.1.1类型定义和使用"></a>3.1.1类型定义和使用</h3><p>对于类型定义MLIR框架提供了3种定义方法，分别是通过C++代码直接定义、通过TD定义、通过IRDL方言进行定义。<br>通过C++代码直接定义的类型并未直接暴露在TD世界中，因此在TD只能将其作为代码片段使用，这样的类型通常是操作不会直接使用，但是在MLIR框架可能会使用，例如LLVMStructType表示LLVM中的结构体类型，这个类型在所有的操作都不需要（结构体只是类型集合体，它没有明确的语义，和操作的要求并不一致。因此在TD中无需定义），但是在MLIR世界到LLVM世界时，会发现一些类型在LLVM中并不存在，所以可以将MLIR世界中的类型通过LLVM世界的结构体进行表示。<br>通过IRDL定义类型是MLIR框架提供的高级功能，它本质上也是基于TD定义类型，在第12章会简单介绍相关概念。<br>通过TD定义类型是最为常见的形式，这是本节的重点。通过TD文件进行定义类型，需要使用mlir-tblgen工具将TD文件转变记录，然后再将记录翻译为C++类，同时mlir-tblgen工具提供了一些胶水代码，将类型注册到方言中，方便开发者使用方言中的类型。下面以内建类型Integer为例介绍如何定义和使用类型。</p>
<h4 id="TD定义"><a href="#TD定义" class="headerlink" title="TD定义"></a>TD定义</h4><p>首先在TD中定义类型，Integer在TD中的定义如代码3-1所示。</p>
<figure class="highlight plaintext"><figcaption><span>Builtin_Integer : Builtin_Type<"Integer"> &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  let summary = &quot;Integer type with arbitrary precision up to a fixed limit&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">  let parameters = (ins &quot;unsigned&quot;:$width, </span><br><span class="line">&quot;SignednessSemantics&quot;:$signedness);</span><br><span class="line">  let builders = [</span><br><span class="line">    //自定义构造器接受两个参数分别是width和signedness，</span><br><span class="line">//width要求是unsigned类型，</span><br><span class="line">//signedness要求是一个自定义约束，类型为SignednessSemantic</span><br><span class="line">//默认值为Signless</span><br><span class="line">    TypeBuilder&lt;(ins &quot;unsigned&quot;:$width,</span><br><span class="line">                     CArg&lt;&quot;SignednessSemantics&quot;, </span><br><span class="line">&quot;Signless&quot;&gt;:$signedness)&gt;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  // IntegerType自定义了StorageClass，可以节约空间</span><br><span class="line">  let genStorageClass = 0;</span><br><span class="line">  let skipDefaultBuilders = 1;</span><br><span class="line">  let genVerifyDecl = 1;</span><br><span class="line">  let extraClassDeclaration = [&#123;</span><br><span class="line">    /// 整数的符号语义信息，用于区别无符号整数、有符号整数</span><br><span class="line">    enum SignednessSemantics : uint32_t &#123;</span><br><span class="line">      Signless, /// 整数没有符号语义</span><br><span class="line">      Signed,   /// 有符号整数</span><br><span class="line">      Unsigned, /// 无符号整数</span><br><span class="line">    &#125;;</span><br><span class="line">    // 其它信息忽略</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了节约篇幅，笔者将Builtin_Integer中两个字段description和extraClassDeclaration进行了删减（下同），其中description字段描述的是Integer类型的描述信息，用于生成文档；extracClassDeclaration描述的是Integer类型需要开发者额外在C++文件用到的类型定义和需要实现的函数声明。<br>下面对Integer的实现做一个简单的介绍，主要字段的含义如下：</p>
<ul>
<li>summary&#x2F;description：Integer类的描述信息，主要用于文档生成。</li>
<li>parameter：Integer类的参数，MLIR中Integer类可以接受两个参数，分别是Integer的位宽和符号标志；通常mlir-tblgen工具基于parameter生成类型构造函数，和skipDefaultBuilders配合使用。</li>
<li>builders：开发者自定义构建Integer对象的构造器。</li>
<li>genStorageClass：表示是否为Integer类自动生成StorageClass，StorageClass用于表示Integer的内存布局，该值为0表示不会自动生成StorageClass。</li>
<li>skipDefaultBuilders：是否为Integer类生成默认的构造函数，该值为1表示不生成。和parameter配合使用。</li>
<li>genVerifyDecl：是否为Integer类生成默认的verify函数声明，该值为1表示生成函数声明；verify函数主要用于校验生成的类型对象是否合法。</li>
<li>extraClassDeclaration：是否需要为Integer类增加额外的C++成员函数和成员变量。<br>另外Integer类继承于Builtin_Type，而Builtin_Type也是一个记录类，它的定义如代码3-2所示。</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>Builtin_Type<string name, list<Trait> traits </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                   string baseCppClass = &quot;::mlir::Type&quot;&gt;</span><br><span class="line">    : TypeDef&lt;Builtin_Dialect, name, traits, baseCppClass&gt; &#123;</span><br><span class="line">  let mnemonic = ?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Builtin_Type是TypeDef的封装类，主要是指定了Integer在生成的对应C++基类为::mlir::Type。<br>当开发者自定义类型时通常直接继承于TypeDef，当然也可以类似于Integer类型的厨房方法封装一个记录基类，此处为Builtin_Type，主要原因是MLIR框架提供了多个内建类型，对于内建类型都会要求生成的对应C++基类为::mlir::Type，所以封装一个记录基类可以节约代码量。</p>
<h4 id="从TD到记录"><a href="#从TD到记录" class="headerlink" title="从TD到记录"></a>从TD到记录</h4><p>接下来使用mlir-tblgen工具将解析TD文件，将记录类翻译为记录信息，Integer类对应的记录以及解释如3-3所示。</p>
<figure class="highlight plaintext"><figcaption><span>Builtin_Integer &#123;// Constraint TypeConstraint Type DialectType AttrOrTypeDef TypeDef Builtin_Type</span><a target="_blank" rel="noopener" href="//这是Builtin_Integer类型的继承信息">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  // Integer类的约束信息，表示该类型可以直接作为类型约束使用。该字段来自TypeDef</span><br><span class="line">  Pred predicate = anonymous_5;</span><br><span class="line">  string summary = &quot;Integer type with arbitrary precision up to a fixed limit&quot;;</span><br><span class="line">  // Integer类类在自动生成的C++代码中的类名</span><br><span class="line">  string cppClassName = &quot;IntegerType&quot;;</span><br><span class="line">  code description = [&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125;];</span><br><span class="line">  string builderCall = &quot;&quot;;</span><br><span class="line">  //IntegerType被方言Builtin_Dialect管理</span><br><span class="line">  Dialect dialect = Builtin_Dialect;</span><br><span class="line">//自动生成的IntegerType继承于该字段定义的值即mlir::Type</span><br><span class="line">  string cppBaseClassName = &quot;::mlir::Type&quot;;</span><br><span class="line">  //IntegerType定义的存储类</span><br><span class="line">  string storageClass = &quot;IntegerTypeStorage&quot;;</span><br><span class="line">  string storageNamespace = &quot;detail&quot;;</span><br><span class="line">  bit genStorageClass = 0;</span><br><span class="line">  bit hasStorageCustomConstructor = 0;</span><br><span class="line">  dag parameters = (ins &quot;unsigned&quot;:$width, &quot;SignednessSemantics&quot;:$signedness);</span><br><span class="line">  list&lt;AttrOrTypeBuilder&gt; builders = [anonymous_344];</span><br><span class="line">  list&lt;Trait&gt; traits = [];</span><br><span class="line">  string mnemonic = ?;</span><br><span class="line">//IntegerType形式使用时的汇编格式，即可以通过字符串格式定义类型的创建</span><br><span class="line">  string assemblyFormat = ?;</span><br><span class="line">  bit hasCustomAssemblyFormat = 0;</span><br><span class="line">  bit genAccessors = 1;</span><br><span class="line">  bit skipDefaultBuilders = 1;</span><br><span class="line">  bit genVerifyDecl = 1;</span><br><span class="line">  code extraClassDeclaration = [&#123;</span><br><span class="line">    /// ......</span><br><span class="line">  &#125;];</span><br><span class="line">  code extraClassDefinition = [&#123;&#125;];</span><br><span class="line">  string cppType = &quot;::mlir::IntegerType&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//这是一个约束信息，在TD中使用CArgs约束Integer构造函数中的第2个参数</span><br><span class="line">def anonymous_343 &#123;// CArg</span><br><span class="line">  string type = &quot;SignednessSemantics&quot;;</span><br><span class="line">  string defaultValue = &quot;Signless&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义构造器的实现</span><br><span class="line">def anonymous_344 &#123;// AttrOrTypeBuilder TypeBuilder</span><br><span class="line">  //通过dagParms生成构造函数，它有2个参数以及参数包含了对应的约束</span><br><span class="line">  dag dagParams = (ins &quot;unsigned&quot;:$width, anonymous_343:$signedness);</span><br><span class="line">  string body = &quot;&quot;;</span><br><span class="line">  string returnType = &quot;&quot;;</span><br><span class="line">  bit hasInferredContextParam = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步骤和llvm-tblgen工具生成记录没有什么区别，唯一不同需要主要的是MLIR类型相关的主要字段含义，关键字段在3-3中进行了解释。关于如何生成记录可以参考《深入理解LLVM：代码生成》第6章。</p>
<h4 id="从记录到C-代码"><a href="#从记录到C-代码" class="headerlink" title="从记录到C++代码"></a>从记录到C++代码</h4><p>再接下来使用mlir-tblgen工具从记录提取信息，生成C++类。上面提到Integer类型需要自定义IntegerTypeStorage，它定义了Integer类型真正的存储结构，代码如代码3-4所示.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//key是用于HasMap中，通过key标识唯一性.</span><br><span class="line">struct IntegerTypeStorage : public TypeStorage &#123;</span><br><span class="line">  IntegerTypeStorage(unsigned width,</span><br><span class="line">                     IntegerType::SignednessSemantics signedness)</span><br><span class="line">      : width(width), signedness(signedness) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ///定义的key类型用于标识hashmap中对象的唯一性.</span><br><span class="line">  using KeyTy = std::tuple&lt;unsigned, IntegerType::SignednessSemantics&gt;;</span><br><span class="line"></span><br><span class="line">  //忽略部分代码</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line">  //定义构造函数，</span><br><span class="line">  static IntegerTypeStorage *construct(TypeStorageAllocator &amp;allocator, KeyTy key) &#123;</span><br><span class="line">    return new (allocator.allocate&lt;IntegerTypeStorage&gt;())</span><br><span class="line">        IntegerTypeStorage(std::get&lt;0&gt;(key), std::get&lt;1&gt;(key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  KeyTy getAsKey() const &#123; return KeyTy(width, signedness); &#125;</span><br><span class="line"></span><br><span class="line">//IntegerType类型包含了2个信息，整数长度和符号。为了节约空间，这里使用伪定义</span><br><span class="line">//这也是为什么不要自动生成存储类的原因，这里可以看到使用32位即可</span><br><span class="line">//如果自动生成存储类，会占用2个32位</span><br><span class="line">  unsigned width : 30;</span><br><span class="line">  IntegerType::SignednessSemantics signedness : 2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IntegerTypeStorage最主要的目的就是存储Integer类型的成员变量，这样做是为了保持Integer类型干净，成员变量全部移入到IntegerTypeStorage中。<br>对于Integer类型，mlir-tblgen工具生成的C++类如3-5所示。</p>
<figure class="highlight plaintext"><figcaption><span>IntegerType : public ::mlir::Type::TypeBase<IntegerType, ::mlir::Type, detail::IntegerTypeStorage> &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">  using Base::Base;</span><br><span class="line">  // 来自于extraClassDeclaration成员函数和成员变量，忽略</span><br><span class="line">  ......</span><br><span class="line">  //自动生成代码</span><br><span class="line">//get函数获取Integer类型对象</span><br><span class="line">//getChecked函数获取Integer类型对象并对Integer类型对象进行验证</span><br><span class="line">//可以看到这2个函数中最后2个参数都是来自于Parameter的输入字段</span><br><span class="line">//根据Parameter获取Integer类型对象，get函数返回Interger类型对象或空对象</span><br><span class="line">//getChecked函数还会对Integer类型对象进行验证</span><br><span class="line">  using Base::getChecked;</span><br><span class="line">  static IntegerType get(::mlir::MLIRContext *context, unsigned width, SignednessSemantics signedness = Signless);</span><br><span class="line">  static IntegerType getChecked(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, ::mlir::MLIRContext *context, unsigned width, SignednessSemantics signedness = Signless);</span><br><span class="line">  //自动生成代码，用于对构造的Integer对象进行验证，</span><br><span class="line">//可以看到verify函数中最后2个参数都是来自于Parameter的输入字段，</span><br><span class="line">//验证工作针对Parameter进行验证，如果对象的参数合法返回成功，否则返回失败</span><br><span class="line">  static ::mlir::LogicalResult verify(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, unsigned width, SignednessSemantics signedness);</span><br><span class="line">  // 自动生成代码，来自于Parameter的输入字段 </span><br><span class="line">  unsigned getWidth() const;</span><br><span class="line">  SignednessSemantics getSignedness() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码3-5中可以看到IntegerType继承于TypeBase，TypeBase的定义如代码3-6所示.</p>
<figure class="highlight plaintext"><figcaption><span>Type &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">  //辅助类类型定义.</span><br><span class="line">  template &lt;typename ConcreteType, typename BaseType, typename StorageType, template &lt;typename T&gt; class... Traits&gt;</span><br><span class="line">  using TypeBase = detail::StorageUserBase&lt;ConcreteType, BaseType, StorageType, detail::TypeUniquer, Traits...&gt;;</span><br><span class="line">  //真正的类型存储类，对于IntegerType来说ImplType就是IntegerTypeStorage</span><br><span class="line">  using ImplType = TypeStorage;</span><br><span class="line"></span><br><span class="line">  using AbstractTy = AbstractType;</span><br><span class="line"></span><br><span class="line">  constexpr Type() = default;</span><br><span class="line">  /* implicit */ Type(const ImplType *impl)</span><br><span class="line">      : impl(const_cast&lt;ImplType *&gt;(impl)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // ......</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">  ImplType *impl&#123;nullptr&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中StorageUserBase也是模板类，定义如3-7所示。</p>
<figure class="highlight plaintext"><figcaption><span><typename ConcreteT, typename BaseT, typename StorageT,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">          typename UniquerT, template &lt;typename T&gt; class... Traits&gt;</span><br><span class="line">class StorageUserBase : public BaseT, public Traits&lt;ConcreteT&gt;... &#123;</span><br><span class="line"></span><br><span class="line">  //辅助类型定义，定义好的类型方便在自动生成代码中使用</span><br><span class="line">  using Base = StorageUserBase&lt;ConcreteT, BaseT, StorageT, UniquerT, Traits...&gt;;</span><br><span class="line">// ......</span><br><span class="line"></span><br><span class="line">  //get函数用于获取或者创建一个新的存储类对象，当存储类型对象存在直接返回</span><br><span class="line">//不存在创建一个新的存储类对象</span><br><span class="line">//从这个类的实现也可以猜测出来，IntegerType中get函数的实现会调用到这里</span><br><span class="line">  template &lt;typename... Args&gt;</span><br><span class="line">static ConcreteT get(MLIRContext *ctx, Args &amp;&amp;...args) &#123;</span><br><span class="line">......</span><br><span class="line">//这里的UnigerT就是具体的存储类型</span><br><span class="line">return UniquerT::template get&lt;ConcreteT&gt;(ctx, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这里，读者朋友应该猜测到是谁调用StorageUserBase的get函数，一般来说是自动生成的代码各个具体类中get函数的实现，但由于这些内建类型比较特殊，它们会被频繁使用，所以设置了缓存，因此IntegerType中get函数的实现如代码3-8所示。</p>
<figure class="highlight plaintext"><figcaption><span>IntegerType::get(MLIRContext *context, unsigned width,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntegerType::SignednessSemantics signedness) &#123;</span><br><span class="line">	//首先从缓存中获取类型对象</span><br><span class="line">if (auto cached = getCachedIntegerType(width, signedness, context))</span><br><span class="line">return cached;</span><br><span class="line">	//调用StorageUserBase中的get获取对象</span><br><span class="line">return Base::get(context, width, signedness);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于如何通过StorageUserBase类中get函数获取类型对象，我们暂时不介绍，在3.1.3节再展开。<br>简单总结如下，在MLIR框架为了方便管理类型对象，将其分为两部分：</p>
<ul>
<li>类型（Type）：提供常见的API，例如get获取类型对象，getChecked用于返回验证通过的类型对象，否则返回为空对象。。</li>
<li>类型存储（TypeStorage）：大多数情况类型对象只需要一个，相对来说比较简单，一般不需要任何额外信息的存储。对于需要实例化多个类戏对象的类型，会通过参数进行区别，对于这样的情况可以为类型设计一个具体的类型存储对象，在存储对象中保存具体的参数，并且可以根据类型存储的信息实例化不同的对象。然后把类型和类型存储进行关联，通过类型中统一的API访问不同的类型对象。<br>通过上述代码可以看出IntegerType类结构如图3-1所示。</li>
</ul>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256960800154.jpg" class="">

<p>当类型定义完成后，需要将类型注册到方言中，这样类型才能被使用。</p>
<h4 id="注册类型到方言中"><a href="#注册类型到方言中" class="headerlink" title="注册类型到方言中"></a>注册类型到方言中</h4><p>假设定义一个自定义类型为Types.td，自定义方言为MyDialect。Types.td在mlir-tblgen自动生成C++代码后默认的文件名为Types.cpp.inc（当然开发者可以指定文件名）。在Dialect方言中定义一个初始化方法initialize，通常会在initialize调用addTypes将类型注册到方言中（方言的initialize方法在方言初始化时被调用）。initialize方法代码如3-9所示。</p>
<figure class="highlight plaintext"><figcaption><span>MyDialect::initialize() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将已经定义的类型类添加到方言中，这里addTypes是一个模版函数，接受类型类</span><br><span class="line">addTypes&lt;</span><br><span class="line">//这里的GET_TYPEDEF_LIST是mlir-tblgen工具生成的宏定义</span><br><span class="line">//在生成类型文件Types.cpp.inc中通过该宏将所有的类型类抓取出来</span><br><span class="line">//其实就是所有类型类的前向声明</span><br><span class="line">#define GET_TYPEDEF_LIST</span><br><span class="line">#include &quot;MyDialect/Types.cpp.inc&quot;</span><br><span class="line">&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addTypes有一个模版参数，可以接受多个类型，并将所有的类型都注册到方言中，方言最终通过一个map对象存储类型对象（具体的存储样式在3.4节会再次介绍）。<br>对于内建类型来说，所有的内建类型可以被所有操作共享，因此内建类型对象会被放在MLIRContext中（MLIRContext是“全局”唯一对象）。</p>
<h3 id="3-1-2类型文法"><a href="#3-1-2类型文法" class="headerlink" title="3.1.2类型文法"></a>3.1.2类型文法</h3><p>在代码3-3中有2个字段，分别是assemblyFormat和hasCustomAssemblyFormat分别用于定义类型对应的标准汇编格式和自定义汇编格式。通过汇编格式的解析可以生成类型对象，或者将类型对象序列化到汇编格式。MLIR框架为类型、属性和操作定义了默认的汇编格式，如果开发者发现默认的汇编格式不符合要求时可以自定义汇编格式（通常自定义格式是为了更好的代码可读性）。<br>在IntegerType中并没有自定义汇编格式，我们来看一下MLIR框架对于类型统一定义的格式。为了准确表达格式的定义，MLIR框架使用EBNF（Extended Backus–Naur Form）进行定义格式，MLIR中类型的定义如3-10所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">type ::= type-alias | dialect-type | builtin-type</span><br><span class="line"></span><br><span class="line">//类型列表的定义，它表示多个类型通过“，”隔开</span><br><span class="line">type-list-no-parens ::=  type (`,` type)*</span><br><span class="line">type-list-parens ::= `(` `)` | `(` type-list-no-parens `)`</span><br><span class="line"></span><br><span class="line">// 变量和类型格式，变量和类型通过符号“：”隔开</span><br><span class="line">ssa-use-and-type ::= ssa-use `:` type</span><br><span class="line">ssa-use ::= value-use</span><br><span class="line"></span><br><span class="line">// 一个非空变量和类型列表，元素通过符号“，”隔开</span><br><span class="line">ssa-use-and-type-list ::= ssa-use-and-type (`,` ssa-use-and-type)*</span><br><span class="line"></span><br><span class="line">//函数类型定义，包含了参数和返回类型，两者通过符号“-&gt;隔开</span><br><span class="line">function-type ::= (type | type-list-parens) `-&gt;` (type | type-list-parens)</span><br><span class="line">//别名类型定义，通过以“！”为起始符号进行标识。</span><br><span class="line">type-alias-def ::= `!` alias-name `=` type</span><br><span class="line">type-alias ::= `!` alias-name</span><br><span class="line"></span><br><span class="line">dialect-namespace ::= bare-id</span><br><span class="line">//下面定义方言类型，例如我们在自定义方言中定义了一个类型，默认格式就是下面的定义</span><br><span class="line">//方言类型的汇编格式就是以“！”开头，有可以分为2种格式</span><br><span class="line">//它们的区别是是否包含简写类型名</span><br><span class="line">dialect-type ::= `!` (opaque-dialect-type | pretty-dialect-type)</span><br><span class="line"></span><br><span class="line">opaque-dialect-type ::= dialect-namespace dialect-type-body</span><br><span class="line"></span><br><span class="line">pretty-dialect-type ::= dialect-namespace `.` pretty-dialect-type-lead-ident dialect-type-body?</span><br><span class="line">pretty-dialect-type-lead-ident ::= `[A-Za-z][A-Za-z0-9._]*`</span><br><span class="line"></span><br><span class="line">dialect-type-body ::= `&lt;` dialect-type-contents+ `&gt;`</span><br><span class="line">dialect-type-contents ::= dialect-type-body</span><br><span class="line">                            | `(` dialect-type-contents+ `)`</span><br><span class="line">                            | `[` dialect-type-contents+ `]`</span><br><span class="line">                            | `&#123;` dialect-type-contents+ `&#125;`</span><br><span class="line">                            | [^\[&lt;(&#123;\]&gt;)&#125;\0]+</span><br></pre></td></tr></table></figure>
<p>MLIR框架实现了默认的类型格式解析，例如我们自定义方言MyDialect中定义了类型String，则它的默认格式为“!MyDialec<String>”。<br>每一个内建类型在MLIR框架都有自己的汇编格式，例如IntegerType的汇编格式对应EBNF格式如代码3-11所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//分别表示有符号整数、无符号整数和不关心符号的整数</span><br><span class="line">//3类整数除了符号信息外，还包括了整数位信息</span><br><span class="line">signed-integer-type ::= `si` [1-9][0-9]*</span><br><span class="line">unsigned-integer-type ::= `ui` [1-9][0-9]*</span><br><span class="line">signless-integer-type ::= `i` [1-9][0-9]*</span><br><span class="line">integer-type ::= signed-integer-type |</span><br><span class="line">                 unsigned-integer-type |</span><br><span class="line">                 signless-integer-type</span><br></pre></td></tr></table></figure>
<p>例如我们使用“i18”表示长度为18位的整数。内建类型的字符串解析以及类型序列化均由MLIR框架提供，例如类型序列化的代码片段如代码3-12所示。。</p>
<figure class="highlight plaintext"><figcaption><span>AsmPrinter::Impl::printTypeImpl(Type type) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TypeSwitch&lt;Type&gt;(type)</span><br><span class="line">......</span><br><span class="line">//忽略其它，仅仅关注IntegerType，针对IntegerType根据符号信息和长度输出格式</span><br><span class="line">.Case&lt;IntegerType&gt;([&amp;](IntegerType integerTy) &#123;</span><br><span class="line">if (integerTy.isSigned())</span><br><span class="line">os &lt;&lt; &#x27;s&#x27;;</span><br><span class="line">else if (integerTy.isUnsigned())</span><br><span class="line">os &lt;&lt; &#x27;u&#x27;;</span><br><span class="line">os &lt;&lt; &#x27;i&#x27; &lt;&lt; integerTy.getWidth();</span><br><span class="line">&#125;)</span><br><span class="line">.....</span><br><span class="line">//此处是方言格式的系列化，说明方言类型和内建类型是同一优先级</span><br><span class="line">.Default([&amp;](Type type) &#123; return printDialectType(type); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型使用和类型对象创建过程"><a href="#类型使用和类型对象创建过程" class="headerlink" title="类型使用和类型对象创建过程"></a>类型使用和类型对象创建过程</h3><p>当定义好类型以后，并且通过胶水代码将类型注册到方言中就可以使用类型。两种常见的使用方式：一是在TD定义操作中使用类型、二是在C++代码中使用类型。在C++代码中使用类型比较简单，因为类型已经被转换为C++类，而且已经注册到方言中，所以可以通过方言获取要使用的类型对象。在TD中使用类型，涉及到的一个问题就是类型的解析，即将一个字符串解析为一个类型，然后将类型和具体的要约束的变量进行关联（要约束的变量指的是操作的返回值、操作的操作数、基本块参数等）。<br>由于定义的类型属于元数据，实例化后的对象称为类型对象。类型对象是特殊的对象，它们的作用是修饰操作的结果或者输入的参数，对于结果或者操作数的类型，它们虽然属于静态信息，但是在运行系统中，需要具体的类型对象才能描述它们。一般来说，一个类型在运行时只需要一个类型对象，但是还有一些类型在运行时存在多个类型对象。例如Integer类型可以接受长度和符号信息，那么si16和ui32分别表示有符号类型16位整数和无符号整数32为整数。使用一个整数类型对象无法描述这2种类型，通常的实现是让IntegerType接受2个参数，并根据不同的参数实例化不同的整数类型对象。<br>需要提一点，同一类型不同参数实例化后的类型对象是不同的对象，而同一参数实例化后的类型对象是一个对象，类型对象具有唯一性。例如si16和ui32是不同的类型对象，但是在使用中多次实例化si16得到的是同一个对象。下面仍然以IntegerType为例来看看如何创建类型对象。<br>代码3-8提供了获取整数类型对象的入口，它会调用代码3-7中的get函数。在代码3-7中可以看到get函数会调用TypeUniquer中get函数，代码片段如3-13所示。</p>
<figure class="highlight plaintext"><figcaption><span>TypeUniquer &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/// 同一类型获取唯一的示例对象.</span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">static T get(MLIRContext *ctx, Args &amp;&amp;...args) &#123;</span><br><span class="line">return getWithTypeID&lt;T, Args...&gt;(ctx, T::getTypeID(),</span><br><span class="line">	std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">static std::enable_if_t&lt;</span><br><span class="line">!std::is_same&lt;typename T::ImplType, TypeStorage&gt;::value, T&gt;</span><br><span class="line">getWithTypeID(MLIRContext *ctx, TypeID typeID, Args &amp;&amp;...args) &#123;</span><br><span class="line">	//可以看到最终调用到MLIRContext中的get函数从而获取对象</span><br><span class="line">	//可以简单认为MLIRContext使用hashmap存放对象</span><br><span class="line">	return ctx-&gt;getTypeUniquer().get&lt;typename T::ImplType&gt;(</span><br><span class="line">[&amp;, typeID](TypeStorage *storage) &#123;</span><br><span class="line">		storage-&gt;initialize(AbstractType::lookup(typeID, ctx));</span><br><span class="line">	&#125;,</span><br><span class="line">	typeID, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//忽略部分代码</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//注册含有参数的类型对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">static std::enable_if_t&lt;</span><br><span class="line">!std::is_same&lt;typename T::ImplType, TypeStorage&gt;::value&gt;</span><br><span class="line">registerType(MLIRContext *ctx, TypeID typeID) &#123;</span><br><span class="line">	ctx-&gt;getTypeUniquer().registerParametricStorageType&lt;typename T::ImplType&gt;(typeID);</span><br><span class="line">&#125;</span><br><span class="line">//注册单示例类型对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">static std::enable_if_t&lt;</span><br><span class="line">std::is_same&lt;typename T::ImplType, TypeStorage&gt;::value&gt;</span><br><span class="line">registerType(MLIRContext *ctx, TypeID typeID) &#123;</span><br><span class="line">	ctx-&gt;getTypeUniquer().registerSingletonStorageType&lt;TypeStorage&gt;</span><br><span class="line">		(typeID, [&amp;ctx, typeID](TypeStorage *storage) &#123;</span><br><span class="line">		storage-&gt;initialize(AbstractType::lookup(typeID, ctx));</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>MLIRContext中TypeUniquer可以认为是一个hashmap，它存储的是键值对（key-value），对于存在key可以直接获取value，当key不存在时先构建value，并插入到容器。这个功能实现在TypeUniquer的get函数中，如代码3-14所示。</p>
<figure class="highlight plaintext"><figcaption><span>StorageUniquer &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">template &lt;typename Storage, typename... Args&gt;</span><br><span class="line">Storage *get(function_ref&lt;void(Storage *)&gt; initFn, TypeID id,</span><br><span class="line">Args &amp;&amp;...args) &#123;</span><br><span class="line">//定义key，可以看到key是由输入参数组成。对于IntegerType的参数有2个</span><br><span class="line">//这里的key其类型在代码3-4中由keyTy定义</span><br><span class="line">auto derivedKey = getKey&lt;Storage&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">//根据key创建一个Hash值，方便进行判断key是否存在</span><br><span class="line">unsigned hashValue = getHash&lt;Storage&gt;(derivedKey);</span><br><span class="line"></span><br><span class="line">//定义key是否相等的函数</span><br><span class="line">auto isEqual = [&amp;derivedKey](const BaseStorage *existing) &#123;</span><br><span class="line">	return static_cast&lt;const Storage &amp;&gt;(*existing) == derivedKey;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//生成一个函数，用于调用构造存储类型对象的构造函数</span><br><span class="line">//对于构造IntegerTypeStorage来说，此处调用的Storage::construct</span><br><span class="line">//就是代码3-4中定义的construct函数</span><br><span class="line">auto ctorFn = [&amp;](StorageAllocator &amp;allocator) &#123;</span><br><span class="line">auto *storage = Storage::construct(allocator, std::move(derivedKey));</span><br><span class="line">if (initFn)</span><br><span class="line">	initFn(storage);</span><br><span class="line">return storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后提一下，在代码3-9中的addTypes最后就是调用到代码3-13中的registerType，而registerType会创建类型对象，这样在get时可以确定IntegerType对象存在，但是IntegerTypeStorage需要根据输入参数确定是否存在。</p>
<h2 id="3-2属性"><a href="#3-2属性" class="headerlink" title="3.2属性"></a>3.2属性</h2><p>属性是为操作和类型增加额外的表达语义，其定义和使用方法非常类似于类型。同样地可以根据属性提供者，可以将MLIR框架中属性分为内建属性和自定义属性。对于内建属性，例如FloatAttr、IntegerAttr、AffineMapAttr等，MLIR框架负责属性的定义、格式解析等，开发者可以直接使用内建属性。当内建属性无法满足开发者需要时，开发者可以自定义属性，对于自定义属性MLIR并未提供显式的约束，所以开发者可以任意定义需要的属性。<br>MLIR中属性分为两种Attribute和Property，为了区别本书将Attribute翻译为属性，Property翻译为特性。特性是一种特殊的属性。</p>
<h3 id="3-2-1属性（Attribute）"><a href="#3-2-1属性（Attribute）" class="headerlink" title="3.2.1属性（Attribute）"></a>3.2.1属性（Attribute）</h3><p>属性和类型非常类似，我们通过内建属性IntegerAttr快速介绍属性的定义和使用。IntegerAttr在TD中的定义如代码3-15所示。</p>
<figure class="highlight plaintext"><figcaption><span>Builtin_IntegerAttr : Builtin_Attr<"Integer"> &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  let summary = &quot;An Attribute containing a integer value&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">  let parameters = (ins AttributeSelfTypeParameter&lt;&quot;&quot;&gt;:$type, &quot;APInt&quot;:$value);</span><br><span class="line">  let builders = [</span><br><span class="line">    .....</span><br><span class="line">  ];</span><br><span class="line">  let extraClassDeclaration = [&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">  let genVerifyDecl = 1;</span><br><span class="line">  let skipDefaultBuilders = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到IntegerAttr的定义和Integer类型几乎一致，字段含义也和Integer类型中字段一致，不同点在于它们的基类不同。类似地，mlir-tblgen工具也会先将TD文件转换记录，然后再将记录转换到C++代码，IntegerAttr对应的C++代码和IntegerType非常类似，这里就不再给出（主要不同点就是基类不同）。最后同样地也需要将属性注册到方言中，和类型处理也几乎一致，唯一不同的是使用addAttributes注册属性类，同样的addAttributes有一个模版参数，可以接受多个属性，并将所有的属性都注册到方言中，方言最终通过一个map对象存储属性对象。</p>
<p>IntergerAttr对应的C++代码如下</p>
<figure class="highlight plaintext"><figcaption><span>IntegerAttrStorage : public ::mlir::AttributeStorage &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  using KeyTy = std::tuple&lt;::mlir::Type, APInt&gt;;</span><br><span class="line">  IntegerAttrStorage(::mlir::Type type, APInt value) : type(std::move(type)), value(std::move(value)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  ::mlir::Type type;</span><br><span class="line">  APInt value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntegerAttr : public ::mlir::Attribute::AttrBase&lt;IntegerAttr, ::mlir::Attribute, detail::IntegerAttrStorage, ::mlir::TypedAttr::Trait&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">  using Base::Base;</span><br><span class="line">  using ValueType = APInt;</span><br><span class="line"></span><br><span class="line">    // 来自于字段extraClassDeclaration</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  // 辅助函数，用于生成IntegerAttr对象以及</span><br><span class="line">  using Base::getChecked;</span><br><span class="line">  static IntegerAttr get(Type type, const APInt &amp;value);</span><br><span class="line">  static IntegerAttr getChecked(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, Type type, const APInt &amp;value);</span><br><span class="line">  static IntegerAttr get(::mlir::MLIRContext *context, const APSInt &amp;value);</span><br><span class="line">  static IntegerAttr getChecked(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, ::mlir::MLIRContext *context, const APSInt &amp;value);</span><br><span class="line">  static IntegerAttr get(Type type, int64_t value);</span><br><span class="line">  static IntegerAttr getChecked(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, Type type, int64_t value);</span><br><span class="line">  static ::mlir::LogicalResult verify(::llvm::function_ref&lt;::mlir::InFlightDiagnostic()&gt; emitError, ::mlir::Type type, APInt value);</span><br><span class="line"> </span><br><span class="line">  // 获取IntegerAttr的成员变量，其真实的存储位于类IntegerAttrStorage中</span><br><span class="line">  ::mlir::Type getType() const;</span><br><span class="line">  APInt getValue() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后同样地需要将属性注册到方言中。</p>
<figure class="highlight plaintext"><figcaption><span>MyDialect::initialize() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// Add the defined attributes to the dialect.</span><br><span class="line">addAttributes&lt;</span><br><span class="line">#define GET_ATTRDEF_LIST</span><br><span class="line">#include &quot;MyDialect/Attributes.cpp.inc&quot;</span><br><span class="line">&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addAttributes有一个模版参数，可以接受多个属性，并将所有的属性都注册到方言中，方言最终通过一个map对象存储属性对象（具体的存储样式在3.4节会再次介绍）。</p>
<h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><p>同样，属性也存在序列化和反序列化过程，即将属性序列化为字符串或者将字符串识转化为属性对象。和类型类似，属性也使用EBNF进行定义。对应的文法如代码3-16所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//属性实体包含左值和右值，左值是属性id或字符串，右值为属性值，中间是符号“=”隔开</span><br><span class="line">attribute-entry ::= (bare-id | string-literal) `=` attribute-value</span><br><span class="line">//属性值也分为3类：别名属性、方言属性、内建属性</span><br><span class="line">attribute-value ::= attribute-alias | dialect-attribute | builtin-attribute</span><br><span class="line">//别名属性是以符号“#”开头</span><br><span class="line">attribute-alias-def ::= `#` alias-name `=` attribute-value</span><br><span class="line">attribute-alias ::= `#` alias-name</span><br><span class="line"></span><br><span class="line">dialect-namespace ::= bare-id</span><br><span class="line">//方言属性以符号“#”开头，定义和方言类型基本一致</span><br><span class="line">dialect-attribute ::= `#` (opaque-dialect-attribute | pretty-dialect-attribute)</span><br><span class="line">opaque-dialect-attribute ::= dialect-namespace dialect-attribute-body</span><br><span class="line">pretty-dialect-attribute ::= dialect-namespace `.` pretty-dialect-attribute-lead-ident</span><br><span class="line">                                              dialect-attribute-body?</span><br><span class="line">pretty-dialect-attribute-lead-ident ::= `[A-Za-z][A-Za-z0-9._]*`</span><br><span class="line"></span><br><span class="line">dialect-attribute-body ::= `&lt;` dialect-attribute-contents+ `&gt;`</span><br><span class="line">dialect-attribute-contents ::= dialect-attribute-body</span><br><span class="line">                            | `(` dialect-attribute-contents+ `)`</span><br><span class="line">                            | `[` dialect-attribute-contents+ `]`</span><br><span class="line">                            | `&#123;` dialect-attribute-contents+ `&#125;`</span><br><span class="line">                            | [^\[&lt;(&#123;\]&gt;)&#125;\0]+    </span><br></pre></td></tr></table></figure>

<p>每一个内建类型在MLIR框架都有自己的汇编格式，例如IntegerType的汇编格式对应EBNF格式如代码3-17所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer-attribute ::= (integer-literal ( `:` (index-type | integer-type) )?)</span><br><span class="line">                      | `true` | `false`</span><br></pre></td></tr></table></figure>
<p>类似于内建类型，内建属性也是由MLIR框架完成序列化和反序列化。读者可以参考源码自行理解。</p>
<h3 id="3-2-2特性（Property）"><a href="#3-2-2特性（Property）" class="headerlink" title="3.2.2特性（Property）"></a>3.2.2特性（Property）</h3><p>特性是一种特殊的属性，在MLIR属性分为两类：固有属性（Inherent attributes）和可丢弃属性（Discardable attributes）。</p>
<ul>
<li>固有属性是指操作定义中为了保证语义完整所携带的属性，对于固有属性操作本身应该验证属性的一致性。例如MLIR框架中arith方言中cmpi操作，其定义：operation ::&#x3D; <code>arith.cmpi</code> $predicate <code>,</code> $lhs <code>,</code> $rhs attr-dict <code>:</code> type($lhs)。操作中predicate是一个属性，它的取值范围只有几个（例如eq、ne、slt、sle、sgt、sge、ult、ule、ugt、uge），表示要进行什么样的比较，这个属性值是比较操作必须的，因此称为固有属性。</li>
<li>可丢弃属性是指为操作添加额外语义，但不是必须内容，可丢弃属性只需要和操作语义兼容即可。我们所说的属性大部分属于这类属性。<br>MLIR社区在演化过程中将固有属性剥离出来，称为特性。其主要目的是固有属性应该归属于操作，而不应该将固有属性放在方言中（因为方言可以认为是相对全局唯一），所以应该将固有属性将抽离出来。</li>
</ul>
<h2 id="3-3操作"><a href="#3-3操作" class="headerlink" title="3.3操作"></a>3.3操作</h2><h3 id="3-3-1操作定义"><a href="#3-3-1操作定义" class="headerlink" title="3.3.1操作定义"></a>3.3.1操作定义</h3><p>第2章中对操作做了介绍，这里主要介绍操作的定义、文法和内存布局。</p>
<h3 id="操作定义"><a href="#操作定义" class="headerlink" title="操作定义"></a>操作定义</h3><p>下面以arith方言中AddI操作为例介绍操作的定义、构建和使用，关于方言会在3.4节介绍。</p>
<h4 id="TD定义-1"><a href="#TD定义-1" class="headerlink" title="TD定义"></a>TD定义</h4><p>首先在TD中定义操作，AddI在TD中的定义如代码3-18所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//通过公共基类可以减少代码量</span><br><span class="line">class Arith_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Op&lt;Arith_Dialect, mnemonic,</span><br><span class="line">       //操作的特质，表示操作的约束，在第4章介绍</span><br><span class="line">       traits #</span><br><span class="line">       [DeclareOpInterfaceMethods&lt;VectorUnrollOpInterface&gt;, NoMemoryEffect] #</span><br><span class="line">       ElementwiseMappable.traits&gt;;</span><br><span class="line">//为所有操作增加特质SameOperandsAndResultType，即操作数和返回值类型相同</span><br><span class="line">class Arith_ArithOp&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Arith_Op&lt;mnemonic, traits # [SameOperandsAndResultType]&gt;;</span><br><span class="line"></span><br><span class="line">// 所有二元操作的基类，这里主要为二元操作提供了相同的汇编格式</span><br><span class="line">class Arith_BinaryOp&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Arith_ArithOp&lt;mnemonic, traits&gt; &#123;</span><br><span class="line">  let assemblyFormat = &quot;$lhs `,` $rhs attr-dict `:` type($result)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 所有整数类型二元操作基类，它们都是有2个操作数、1个返回值，还可以求整数范围</span><br><span class="line">class Arith_IntBinaryOp&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Arith_BinaryOp&lt;mnemonic, traits #</span><br><span class="line">      [DeclareOpInterfaceMethods&lt;InferIntRangeInterface&gt;]&gt;,</span><br><span class="line">    Arguments&lt;(ins SignlessIntegerLike:$lhs, SignlessIntegerLike:$rhs)&gt;,</span><br><span class="line">    Results&lt;(outs SignlessIntegerLike:$result)&gt;;</span><br><span class="line"></span><br><span class="line">// 所有整数类型二元操作且没有副作用操作的基类，即增加了pure特质约束</span><br><span class="line">class Arith_TotalIntBinaryOp&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :</span><br><span class="line">    Arith_IntBinaryOp&lt;mnemonic, traits # [Pure]&gt;;</span><br><span class="line"></span><br><span class="line">//操作AddI的定义，其中“addi”为助记符，“Commutative”表示操作数可交互的约束</span><br><span class="line">def Arith_AddIOp : Arith_TotalIntBinaryOp&lt;&quot;addi&quot;, [Commutative]&gt; &#123;</span><br><span class="line">  let summary = &quot;integer addition operation&quot;;</span><br><span class="line">  let description = [&#123;</span><br><span class="line">    // ......</span><br><span class="line">  &#125;];</span><br><span class="line">  let hasFolder = 1;</span><br><span class="line">  let hasCanonicalizer = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例代码非常简单，只包含了7个字段，含义分别如下：</p>
<ul>
<li>arguments：继承于Arguments，描述操作接受的参数，本例中AddI操作接受2个参数，都是“类似”无符号类型的整数（例如整数、Index、向量类型且向量元素为整数、Tensor类型且Tensor元素类型为整数等），名字分别为lhs和rhs。</li>
<li>results：继承于Results，描述操作的结果，本例中AddI操作返回结果是“类似”无符号类型的整数，名字为result。</li>
<li>summary：操作的简单描述。</li>
<li>description：操作的详细描述，在本例中提供了使用AddI操作的示例，因篇幅原因，本书将其删除。</li>
<li>hasFolder：表示mlir-tblgen工具会生成一个函数名为fold的函数声明，开发者需要进行实现。fold指的是操作可以进行常量折叠的实现。</li>
<li>hasCanonicalizer：表示mlir-tblgen工具会生成一个函数名为getCanonicalizationPatterns的函数声明，开发者需要进行实现。getCanonicalizationPatterns指的是操作可以进行归一化的实现（归一化的目的是为了更好地优化，例如对于加法来说，有两个操作数，一个为变量另一个外常量，总是要求变量在前，常量在后，这样的行为就是归一化）。</li>
<li>assemblyFormat：表示操作的汇编格式。<br>实际上操作还还有一些其他字段可以定义，例如hasVerifier表示是否需要开发者提供验证器（在第4章介绍）、extraClassDeclaration声明C++需要实现的函数等。默认情况下，不提供的字段mlir-tblgen会提供一个默认值，一般不会生成相应代码。</li>
</ul>
<h4 id="从TD到记录-1"><a href="#从TD到记录-1" class="headerlink" title="从TD到记录"></a>从TD到记录</h4><p>接下来mlir-gblgen工具将解析TD文件，将记录类翻译为record信息，例如AddI类对应的record如下：</p>
<figure class="highlight plaintext"><figcaption><span>Arith_AddIOp &#123;// Op Arith_Op Arith_ArithOp Arith_BinaryOp Arguments Results Arith_IntBinaryOp Arith_TotalIntBinaryOp 这是AddI操作的基类</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  Dialect opDialect = Arith_Dialect;//所属方言</span><br><span class="line">  string opName = &quot;addi&quot;;//操作的名字</span><br><span class="line">  string cppNamespace = &quot;::mlir::arith&quot;;//对应生成的C++代码所在的命名空间</span><br><span class="line">  string summary = &quot;integer addition operation&quot;;//概述信息</span><br><span class="line">  code description = [&#123; //详细描述信息</span><br><span class="line">    // ......</span><br><span class="line">  &#125;];</span><br><span class="line">  OpDocGroup opDocGroup = ?;//文档组</span><br><span class="line">..//操作的参数，一般来说mlir-tblgen会根据该信息生成build函数</span><br><span class="line">  dag arguments = (ins SignlessIntegerLike:$lhs, SignlessIntegerLike:$rhs);</span><br><span class="line">  dag results = (outs SignlessIntegerLike:$result);//操作的返回值</span><br><span class="line">  dag regions = (region);//操作定义的区域</span><br><span class="line">  dag successors = (successor);//操作定义的后继基本块</span><br><span class="line">  list&lt;OpBuilder&gt; builders = ?;//用户自定义的构造函数</span><br><span class="line">  bit skipDefaultBuilders = 0;//是否放弃自动生成构造函数</span><br><span class="line">//AddI操作对应的汇编格式</span><br><span class="line">  string assemblyFormat = &quot;$lhs `,` $rhs attr-dict `:` type($result)&quot;;</span><br><span class="line">  bit hasCustomAssemblyFormat = 0;//开是否有发者自定义汇编格式</span><br><span class="line">  bit hasVerifier = 0;//是否生成verify函数，用于验证操作创建后是否合法</span><br><span class="line">  //是否生成regionVerify函数，用验证操作region是否合法</span><br><span class="line">  bit hasRegionVerifier = 0;</span><br><span class="line">  //是否生成canonicalizer相关函数，用于Pass执行过程进行归一化优化</span><br><span class="line">  bit hasCanonicalizer = 1;</span><br><span class="line">  bit hasCanonicalizeMethod = 0;</span><br><span class="line">  //是否生成fold相关函数，用于Pass执行过程进行折叠优化</span><br><span class="line">  bit hasFolder = 1;</span><br><span class="line">  bit useCustomPropertiesEncoding = 0;//是否有自定义编码</span><br><span class="line">  //操作定义的特质，表示对操作的约束</span><br><span class="line">  list&lt;Trait&gt; traits = [Commutative, Pure, anonymous_443, SameOperandsAndResultType, anonymous_442, NoMemoryEffect, Elementwise, Scalarizable, Vectorizable, Tensorizable];</span><br><span class="line">  //为操作定义的C++代码</span><br><span class="line">  string extraClassDeclaration = ?;</span><br><span class="line">  string extraClassDefinition = ?;</span><br><span class="line">&#125;</span><br><span class="line">//操作的一个约束，该约束是VectorUnrollOpInterface，可以支持向量展开</span><br><span class="line">def anonymous_442 &#123;// DeclareInterfaceMethods Interface Trait NativeTrait InterfaceTrait OpInterfaceTrait OpInterface DeclareOpInterfaceMethods</span><br><span class="line">  // ......</span><br><span class="line">  string cppInterfaceName = &quot;VectorUnrollOpInterface&quot;;</span><br><span class="line">  // ......</span><br><span class="line">&#125;</span><br><span class="line">//操作的一个约束，该约束是InferIntRangeInterface，可以支持整数范围推断</span><br><span class="line">def anonymous_443 &#123;// DeclareInterfaceMethods Interface Trait NativeTrait InterfaceTrait OpInterfaceTrait OpInterface DeclareOpInterfaceMethods</span><br><span class="line">  // ......</span><br><span class="line">  string cppInterfaceName = &quot;InferIntRangeInterface&quot;;</span><br><span class="line">  // ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里字段的含义如代码3-19注释所示，本章主要要关心操作定义、解析相关字段，而其它部分字段的使用将在后续章节介绍。</p>
<h4 id="从记录到C-代码-1"><a href="#从记录到C-代码-1" class="headerlink" title="从记录到C++代码"></a>从记录到C++代码</h4><p>再接下来使用mlir-tblgen工具从记录提取信息，生成C++类。对于代码3-19使用mlir-tblgen工具生成的C++类如代码3-20所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">namespace detail &#123;</span><br><span class="line">class AddIOpGenericAdaptorBase &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">template &lt;typename RangeT&gt;</span><br><span class="line">class AddIOpGenericAdaptor : public detail::AddIOpGenericAdaptorBase &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AddIOpAdaptor : public AddIOpGenericAdaptor&lt;::mlir::ValueRange&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">  using AddIOpGenericAdaptor::AddIOpGenericAdaptor;</span><br><span class="line">  AddIOpAdaptor(AddIOp op);</span><br><span class="line"></span><br><span class="line">  ::mlir::LogicalResult verify(::mlir::Location loc);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AddIOp : public ::mlir::Op&lt;AddIOp, ::mlir::OpTrait::ZeroRegions, ......&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">  using Op::Op;</span><br><span class="line">  using Op::print;</span><br><span class="line">  // Adaptor提供给外部使用，在方言降级中会使用到该类型</span><br><span class="line">  using Adaptor = AddIOpAdaptor;</span><br><span class="line">  // GenericAdaptor和FoldAdaptor用于fold函数的参数，为什么引入Adaptor类型？这里先留一个问题，在方言降级中详细介绍</span><br><span class="line">  template &lt;typename RangeT&gt;</span><br><span class="line">  using GenericAdaptor = AddIOpGenericAdaptor&lt;RangeT&gt;;</span><br><span class="line">  using FoldAdaptor = GenericAdaptor&lt;::llvm::ArrayRef&lt;::mlir::Attribute&gt;&gt;;</span><br><span class="line">  //以下函数用于获取操作相关的信息包括：属性名、操作名、操作数、返回值</span><br><span class="line">  static ::llvm::ArrayRef&lt;::llvm::StringRef&gt; getAttributeNames() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static constexpr ::llvm::StringLiteral getOperationName() &#123;</span><br><span class="line">    return ::llvm::StringLiteral(&quot;arith.andi&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::pair&lt;unsigned, unsigned&gt; getODSOperandIndexAndLength(unsigned index);</span><br><span class="line">  ::mlir::Operation::operand_range getODSOperands(unsigned index);</span><br><span class="line">  ::mlir::Value getLhs();</span><br><span class="line">  ::mlir::Value getRhs();</span><br><span class="line">  ::mlir::OpOperand &amp;getLhsMutable();</span><br><span class="line">  ::mlir::OpOperand &amp;getRhsMutable();</span><br><span class="line">  std::pair&lt;unsigned, unsigned&gt; getODSResultIndexAndLength(unsigned index);</span><br><span class="line">  ::mlir::Operation::result_range getODSResults(unsigned index);</span><br><span class="line">  ::mlir::Value getResult();</span><br><span class="line">  //以下的build函数用于构建AddI操作对象</span><br><span class="line">  static void build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs);</span><br><span class="line">  static void build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::Value lhs, ::mlir::Value rhs);</span><br><span class="line">  static void build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs);</span><br><span class="line">  static void build(::mlir::OpBuilder &amp;, ::mlir::OperationState &amp;odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef&lt;::mlir::NamedAttribute&gt; attributes = &#123;&#125;);</span><br><span class="line">  static void build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef&lt;::mlir::NamedAttribute&gt; attributes = &#123;&#125;);</span><br><span class="line">  // 用于验证AddI对象</span><br><span class="line">  ::mlir::LogicalResult verifyInvariantsImpl();</span><br><span class="line">  ::mlir::LogicalResult verifyInvariants();</span><br><span class="line">  // 用于归一化和常量折叠</span><br><span class="line">  static void getCanonicalizationPatterns(::mlir::RewritePatternSet &amp;results, ::mlir::MLIRContext *context);</span><br><span class="line">  ::mlir::OpFoldResult fold(FoldAdaptor adaptor);</span><br><span class="line">  // 用于结果类型推导</span><br><span class="line">  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::std::optional&lt;::mlir::Location&gt; location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl&lt;::mlir::Type&gt;&amp;inferredReturnTypes);</span><br><span class="line">  void inferResultRanges(::llvm::ArrayRef&lt;::mlir::ConstantIntRanges&gt; argRanges, ::mlir::SetIntRangeFn setResultRanges);</span><br><span class="line">  // 用于将字符串解析为AddI对象，其输入格式由assemblyFormat定义</span><br><span class="line">  static ::mlir::ParseResult parse(::mlir::OpAsmParser &amp;parser, ::mlir::OperationState &amp;result);</span><br><span class="line">  // 用于将AddI对象输出为字符串，其输出格式由assemblyFormat定义</span><br><span class="line">  void print(::mlir::OpAsmPrinter &amp;_odsPrinter);</span><br><span class="line">  // 由于AddI操作继承于特质NoMemoryEffects，这个特质需要实现一个函数</span><br><span class="line">// getEffects，对于NoMemoryEffects其实现为空，在第4章还会讨论特质</span><br><span class="line">  void getEffects(::llvm::SmallVectorImpl&lt;::mlir::SideEffects::EffectInstance&lt;::mlir::MemoryEffects::Effect&gt;&gt; &amp;effects);</span><br><span class="line">public:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; // namespace arith</span><br><span class="line"></span><br><span class="line">&#125; // namespace mlir</span><br><span class="line">// 这是一个宏，用于声明操作的类型号（它是一个标识符，通过该标识符可以识别操作）</span><br><span class="line">MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::arith::AndIOp)</span><br><span class="line">在生成的C++实现文件中通常还会有宏MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::arith::AndIOp)//实现这个操作的标识符。</span><br></pre></td></tr></table></figure>
<p>接下来看几个函数的实现。代码如3-21所示。</p>
<figure class="highlight plaintext"><figcaption><span>用于获取操作数，从代码实现中可以看出AddI类应有一个</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// getOperation函数返回Operation*的类型，它包含了操作数</span><br><span class="line">::mlir::Operation::operand_range AddIOp::getODSOperands(unsigned index) &#123;</span><br><span class="line">  auto valueRange = getODSOperandIndexAndLength(index);</span><br><span class="line">  return &#123;std::next(getOperation()-&gt;operand_begin(), valueRange.first),  std::next(getOperation()-&gt;operand_begin(), valueRange.first + valueRange.second)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">// 用于构建AddI操作对象。从代码上看，构建并没有真正完成</span><br><span class="line">// 而是把操作数以及返回类型设置到OperationState的对象中</span><br><span class="line">void AddIOp::build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) &#123;</span><br><span class="line">  odsState.addOperands(lhs);</span><br><span class="line">  odsState.addOperands(rhs);</span><br><span class="line">  odsState.addTypes(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于构建AddI操作对象。从代码上看，构建并没有真正完成，</span><br><span class="line">// 而是把操作数以及返回类型设置到OperationState的对象中。</span><br><span class="line">// 该例更为特殊，因为返回类型未知，所以调用了inferReturnTypes推断返回类型</span><br><span class="line">void AddIOp::build(::mlir::OpBuilder &amp;odsBuilder, ::mlir::OperationState &amp;odsState, ::mlir::Value lhs, ::mlir::Value rhs) &#123;</span><br><span class="line">  odsState.addOperands(lhs);</span><br><span class="line">  odsState.addOperands(rhs);</span><br><span class="line"></span><br><span class="line">// 推断结果的类型，这里调用了接口inferReturnTypes，将在第4章介绍</span><br><span class="line">        ::llvm::SmallVector&lt;::mlir::Type, 2&gt; inferredReturnTypes;</span><br><span class="line">        if (::mlir::succeeded(AddIOp::inferReturnTypes(</span><br><span class="line">         odsBuilder.getContext(),odsState.location, odsState.operands,</span><br><span class="line">         odsState.attributes.getDictionary(odsState.getContext()),</span><br><span class="line">                      odsState.getRawProperties(),</span><br><span class="line">                      odsState.regions, inferredReturnTypes)))</span><br><span class="line">                      odsState.addTypes(inferredReturnTypes);</span><br><span class="line">        else</span><br><span class="line">          ::llvm::report_fatal_error(&quot;Failed to infer result type(s).&quot;);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">// 用于验证AddI操作对象。该函数在构造完AddI对象后被MLIR框架调用</span><br><span class="line">::mlir::LogicalResult AddIOp::verifyInvariantsImpl() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned index = 0; (void)index;</span><br><span class="line">    auto valueGroup0 = getODSOperands(0);</span><br><span class="line"></span><br><span class="line">    for (auto v : valueGroup0) &#123;</span><br><span class="line">// 函数__mlir_ods_local_type_constraint_ArithOps1也是自动生成的代码</span><br><span class="line">// 它验证操作数0的类型是满足要求。</span><br><span class="line">// 在AddI的定义时提到要求操作数和返回值都是类似整数类型，</span><br><span class="line">// 这里就会对它的类型进行判断，如果合法则构建对象成功，否则构造对象失败。</span><br><span class="line">      if (::mlir::failed(__mlir_ods_local_type_constraint_ArithOps1(*this, v.getType(), &quot;operand&quot;, index++)))</span><br><span class="line">        return ::mlir::failure();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AddI操作的继承于Op类，Op继承于OpState和各种特质。这里我们不再给出详细的代码，直接给出类结构图如图3-2所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969190851.jpg" class="">

<p>OpState仅仅包括了Operation*的字段，Operation的类结构图如3-3所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969369644.jpg" class="">

<p>Operation继承于TrailingObjects，这里为了便于读者理解Operation类，需要对TrailingObjects做一个简单的介绍。TrailingObjects是LLVM中一个比较方便的辅助类，目的是为目标类添加额外的成员变量，例如Operation通过TrailingObjects最多添加5类成员变量（对TrailingObject就是有额外5个模版参数），每一类成员变量可以包含0个或者多个，具体添加多少个可以在Operation对象分配是确定，通过TrailingObject辅助类可以方便的找每类成员变量的位置。TralingObjects为了能够实现这个功能，将这5个模版参数依次通过继承的方式展开，从而方便确定成员变量的位置。对于的TralingObjects类结构展开如3-4所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256969557877.jpg" class="">

<p>TrailingObjects方便了Operation动态添加成员变量，但是因为其比较复杂，难以理解，特别是涉及到模版继承展开的过程，对这一过程感兴趣的读者可以通过<a target="_blank" rel="noopener" href="https://cppinsights.io/s/789b1c66%E6%9F%A5%E7%9C%8B%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%E3%80%82%E5%9C%A83.3.2%E8%8A%82%E8%BF%98%E4%BC%9A%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%8B%E7%BB%8DTrailingObjects%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82">https://cppinsights.io/s/789b1c66查看详细过程。在3.3.2节还会通过对象内存布局进一步介绍TrailingObjects的功能。</a><br>注意：为什么具体类的类结构图设计成图3-2的样子？主要有几个原因，一方面是因为所有的具体操作类和特质之间直接通过继承不符合现代C++对于继承的使用，因为特质转换到具体操作类时可以发现所有的具体类本质上相互影响，而通过CRTP（Curiously Recurring Template Pattern）则将类的多态变成了静态的多态（即仅保留动态使用Polymorphic Use），关于CRTP可以参考《深入理解LLVM：代码生成》附录C。另外一方面原因是在实现具体操作的创建过程中，需要有一些公共功能，它们需要进行抽象，所以设计了Op类，在3.3.2节会进一步介绍。</p>
<h4 id="注册操作到方言中"><a href="#注册操作到方言中" class="headerlink" title="注册操作到方言中"></a>注册操作到方言中</h4><p>操作定义完成后，来需要将操作注册到方言中，就可以使用。以arith方言为例，其操作注册代码如3-22所示。</p>
<figure class="highlight plaintext"><figcaption><span>arith::ArithmeticDialect::initialize() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将已经定义的操作类添加到方言中，这里addOperations是一个模版函数，接受操作类</span><br><span class="line">addOperations&lt;</span><br><span class="line">//这里的GET_OP_LIST是mlir-tblgen工具生成的宏定义</span><br><span class="line">//在生成类型文件ArithmeticOps.cpp.inc中通过该宏将所有的类型类抓取出来</span><br><span class="line">//其实就是所有类型类的前向声明</span><br><span class="line">#define GET_OP_LIST</span><br><span class="line">#include &quot;mlir/Dialect/Arithmetic/IR/ArithmeticOps.cpp.inc&quot;</span><br><span class="line">&gt;();</span><br><span class="line">......;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加操作使用模版函数addOperations，它接受多个操作类作为参数。但是操作注册和类型、属性注册少有不同，注册操作时Initialize函数并不会真正的实例化对象，而仅仅将操作元数据注册到方言中，主要原因是操作可以被多次实例化。在MLIR框架中设计了RegisteredOperationName类，它存储了操作类的标识符、名字等信息，然后RegisteredOperationName实例化的对象会被存储到MLIRContext中，当需要实例化操作对象时，会通过RegisteredOperationName判断操作是否已经注册，对于注册的操作可以实例化操作对象。</p>
<h3 id="3-3-2操作内存布局"><a href="#3-3-2操作内存布局" class="headerlink" title="3.3.2操作内存布局"></a>3.3.2操作内存布局</h3><p>MLIR框架自动生成的代码看起来比较简单，但是对于读者理解并不友好，一个典型的现象是自动生成需要和MLIR框架配合才能理解其含义，例如build函数用于生成对象，但实际上build仅仅定义了一个OperationState对象，MLIR框架通过OperationState对象完成真正操作对象的构建。这部分代码位于OpBuilder中的create函数，其定义如代码3-23所示。</p>
  <figure class="highlight plaintext"><figcaption><span><typename OpTy, typename... Args></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  OpTy create(Location location, Args &amp;&amp;...args) &#123;</span><br><span class="line">    OperationState state(location,</span><br><span class="line">getCheckRegisteredInfo&lt;OpTy&gt;(location.getContext()));</span><br><span class="line">// 这里的build就是代码3-20中的build函数，返回state对象</span><br><span class="line">    OpTy::build(*this, state, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">// 调用Operation::create，传递state对象构造AddI对象</span><br><span class="line">    auto *op = create(state);</span><br><span class="line">    //将operation*类型动态转换到AddI类型</span><br><span class="line">    auto result = dyn_cast&lt;OpTy&gt;(op);</span><br><span class="line">    assert(result &amp;&amp; &quot;builder didn&#x27;t return the right type&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>图3-2和图3-3介绍AddIOp的类继承结构以及AddiOp成员变量真正的存储结构是Operation。Operation类通过TrailingObjects结构实现包含了AddIOp操作具体的信息，比如、区域个数、是否包含操作数等信息，<br>一般来说，当类定义完成后，它实例化的对象大小也是固定，但是这不满足MLIR对操作对象的要求，因为不同的操作对象操作数、返回结果、属性等各不相同，也就是说Operation类本身静态大小并不能反映操作对象的大小。也就是说Operation实例化的对象大小应该动态变化，这样就能反映操作对象。为此MLIR框架提供的build函数，在build函数中提供OperationState对象（该对象可以由mlir-tblgen工具根据build函数原型生成，也可以由开发者提供），这个对象存储操作数、返回结果类型、属性等，再由MLIR框架根据OperationState对象动态实例化真正的操作对象。<br>实际上代码3-23中的create函数会体现上面的设计，在create函数中会调用Operation::create函数，在Operation::create函数中会先分配内存，然后依次初始化Operation的字段，代码如代码3-24所示.</p>
<figure class="highlight plaintext"><figcaption><span>*Operation::create(Location location, OperationName name,</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">TypeRange resultTypes, ValueRange operands,</span><br><span class="line">NamedAttrList &amp;&amp;attributes, BlockRange successors,</span><br><span class="line">unsigned numRegions) &#123;</span><br><span class="line">.....</span><br><span class="line">//获取操作返回值占有的空间，当返回值个数小于等于5，使用inlineResult表示</span><br><span class="line">//返回值个数超过5的部分使用outofLineRresult表示</span><br><span class="line">unsigned numTrailingResults = OpResult::getNumTrailing(resultTypes.size());</span><br><span class="line">unsigned numInlineResults = OpResult::getNumInline(resultTypes.size());</span><br><span class="line">//获取操作基本块个数</span><br><span class="line">unsigned numSuccessors = successors.size();</span><br><span class="line">//获取操作的操作数个数</span><br><span class="line">unsigned numOperands = operands.size();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">//调用TrailingObjects中的totaliSizeToAlloc获取真正需要分配的内存空间大小</span><br><span class="line">//该函数传递的参数是5类成员变量的个数，当个数为0不分配空间</span><br><span class="line">size_t byteSize =</span><br><span class="line">totalSizeToAlloc&lt;detail::OperandStorage, BlockOperand, Region, OpOperand&gt;(</span><br><span class="line">needsOperandStorage ? 1 : 0, numSuccessors, numRegions, numOperands);</span><br><span class="line">//计算返回值所占有的内存空间</span><br><span class="line">size_t prefixByteSize = llvm::alignTo(</span><br><span class="line">Operation::prefixAllocSize(numTrailingResults, numInlineResults),</span><br><span class="line">alignof(Operation));</span><br><span class="line">//总的分配空间包括：返回值空间、operation本身空间以及5类成员变量空间</span><br><span class="line">char *mallocMem = reinterpret_cast&lt;char *&gt;(malloc(byteSize + prefixByteSize));</span><br><span class="line">//这里返回的内存起始地址是Operation结构开始的位置</span><br><span class="line">void *rawMem = mallocMem + prefixByteSize;</span><br><span class="line"></span><br><span class="line">// 使用pleacement new初始化Operation结构</span><br><span class="line">Operation *op = ::new (rawMem) Operation(</span><br><span class="line">location, name, numResults, numSuccessors, numRegions,</span><br><span class="line">attributes.getDictionary(location.getContext()), needsOperandStorage);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">// 对返回值进行初始化，注意返回值存放的是value类型</span><br><span class="line">auto resultTypeIt = resultTypes.begin();</span><br><span class="line">for (unsigned i = 0; i &lt; numInlineResults; ++i, ++resultTypeIt)</span><br><span class="line">new (op-&gt;getInlineOpResult(i)) detail::InlineOpResult(*resultTypeIt, i);</span><br><span class="line">for (unsigned i = 0; i &lt; numTrailingResults; ++i, ++resultTypeIt) &#123;</span><br><span class="line">new (op-&gt;getOutOfLineOpResult(i))</span><br><span class="line">detail::OutOfLineOpResult(*resultTypeIt, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化区域空间</span><br><span class="line">for (unsigned i = 0; i != numRegions; ++i)</span><br><span class="line">new (&amp;op-&gt;getRegion(i)) Region(op);</span><br><span class="line"></span><br><span class="line">// 初始化操作数相关的空间</span><br><span class="line">if (needsOperandStorage) &#123;</span><br><span class="line">new (&amp;op-&gt;getOperandStorage()) detail::OperandStorage(</span><br><span class="line">op, op-&gt;getTrailingObjects&lt;OpOperand&gt;(), operands);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化基本块空间</span><br><span class="line">auto blockOperands = op-&gt;getBlockOperands();</span><br><span class="line">for (unsigned i = 0; i != numSuccessors; ++i)</span><br><span class="line">new (&amp;blockOperands[i]) BlockOperand(op, successors[i]);</span><br><span class="line"></span><br><span class="line">return op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码3-24可以得到Operation的对象布局可以分为3部分，分别是返回值、Operation本身固有属性以及TrailingObjects对象，从MLIR框架代码可知Operation固有属性包含64字节，而其它2部分则依赖于具体操作真实的大小，而Operation的对象布局也是具体操作的对象布局，如图3-5所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256971083934.jpg" class="">


<p>使用create函数创建的对象Operation<em>类型，要想得到具体的类型指针AddIOp在代码中是通过dyn_cast<OpTy>即dyn_cast<AddIOp>完成。我们再次回顾一下图3-2，可以发现Operation类和AddIop根本没有继承关系（AddIOp只是包括一个Operation</em>的字段），那为什么可以使用dyn_cast实现类型转换？这涉及到LLVM框架提供动态转换能力，由于这一部分知识和标准的C++有所不同，我们稍微展开介绍一下。<br>我们知道在C++中dynamic_cast可以将基类指针动态转换为派生类指针，但这个前提是基类实现了虚函数，因为dynamic_cast依赖于RTTI（RunTime-Type-Info，运行时类型信息），而RTTI一般在实现中通常依赖于虚指针和虚表。这就产生一个问题，对于没有虚函数的继承关系不能使用dynamic_cast，如果使用会在编译期报错，即不能使用dynamic_cast处理这样的场景。而实际上这一约束并不十分合理，我们更希望的是对于继承关系当从基类指针转到派生类时都可以使用dynamic_cast，为此LLVM提供了dyn_cast实现这一功能。这里以Operation<em>到AddIOp</em>的转换为例简单介绍dyn_cast的实现，对于指针的转换dyn_cast对应的代码如3-25所示。</p>
<figure class="highlight plaintext"><figcaption><span><typename To, typename From></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) &#123;</span><br><span class="line">  assert(detail::isPresent(Val) &amp;&amp; &quot;dyn_cast on a non-existent value&quot;);</span><br><span class="line">  return CastInfo&lt;To, From *&gt;::doCastIfPossible(Val);</span><br><span class="line">&#125;</span><br><span class="line">在代码3-25中可以看到dyn_cast的实现依赖于CastInfo类中的doCastIfPossible函数，MLIR框架对于Operation定义的CastInfo如代码3-26所示。</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct CastInfo&lt;T, ::mlir::Operation *&gt;</span><br><span class="line">    : public ValueFromPointerCast&lt;T, ::mlir::Operation,</span><br><span class="line">                                  CastInfo&lt;T, ::mlir::Operation *&gt;&gt; &#123;</span><br><span class="line">  //isPossible函数主要用于确定Operation*是否可以转换到类型T，这里调用classOf</span><br><span class="line">  static bool isPossible(::mlir::Operation *op) &#123; return T::classof(op); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename To, typename From, typename Derived = void&gt;</span><br><span class="line">struct ValueFromPointerCast</span><br><span class="line">    : public CastIsPossible&lt;To, From *&gt;,</span><br><span class="line">      public NullableValueCastFailed&lt;To&gt;,</span><br><span class="line">      public DefaultDoCastIfPossible&lt;</span><br><span class="line">          To, From *,</span><br><span class="line">          detail::SelfType&lt;Derived, ValueFromPointerCast&lt;To, From&gt;&gt;&gt; &#123;</span><br><span class="line">  //定义doCast，用于真实的转换，从From*到To*。进一步可以看到doCast的实现调用</span><br><span class="line">//To的构造函数实现，传递参数为f，即一定存在形如AddIOp(operation*)的实现</span><br><span class="line">  static inline To doCast(From *f) &#123; return To(f); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename To, typename From, typename Derived&gt;</span><br><span class="line">struct DefaultDoCastIfPossible &#123;</span><br><span class="line">    //dyn_cast真正的实现，先通过isPossible判断类型是否可以转换</span><br><span class="line">//如果可以调用doCast构造出真正的To对象</span><br><span class="line">static To doCastIfPossible(From f) &#123;</span><br><span class="line">if (!Derived::isPossible(f))</span><br><span class="line">	return Derived::castFailed();</span><br><span class="line">return Derived::doCast(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码3-26中可以看出从Operation<em>到AddIOp</em>的转换过程就是先判断是否可以转换，如果可以构造对象。我们知道AddIOp是通过mlir-tblgen自动生成的代码，要实现这样的功能稍显复杂，另一方面，对于所有的具体操作都需要从Operation*转换得到，所以MLIR框架抽象了模版类Op，实现了calssOf函数以及Op的构造函数，如代码3-27所示。</p>
<figure class="highlight plaintext"><figcaption><span><typename ConcreteType, template <typename T> class... Traits></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Op : public OpState, public Traits&lt;ConcreteType&gt;... &#123;</span><br><span class="line">public:</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">static bool classof(Operation *op) &#123;</span><br><span class="line">    //根据Operation获取具体操作的ID，ID参看代码3-20中定义</span><br><span class="line">//如果ID和具体操作ID相同则可以转换，否则不能转换</span><br><span class="line">if (auto info = op-&gt;getRegisteredInfo())</span><br><span class="line">	return TypeID::get&lt;ConcreteType&gt;() == info-&gt;getTypeID();</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//这个就是构赞函数，可以将Operation*转换到具体操作</span><br><span class="line">Op(std::nullptr_t) : OpState(nullptr) &#123;&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此具体操作类对象的创建完成。<br>注意：操作对象的创建是通过函数build得到，而类型、属性则是通过函数get得到。都是获得对象，为什么MLIR框架使用的函数名？原因就是通常类型对象只需要一份，使用get表示创建的对象是同一个；而操作对象随着IR随时产生，使用build表示创建不同对象，框架使用不同的函数名区别获得对象的含义不同。</p>
<h3 id="3-3-3操作文法"><a href="#3-3-3操作文法" class="headerlink" title="3.3.3操作文法"></a>3.3.3操作文法</h3><p>操作也存在序列化和反序列化过程，即将操作对象序列化为字符串或者将字符串识转化为操作对象。和类型、属性类似，操作也使用EBNF进行定义。对应的文法如代码3-28所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">operation             ::= op-result-list? (generic-operation | </span><br><span class="line">                         custom-operation)   trailing-location?</span><br><span class="line">//一般操作包含：名字以及“（）”，其中“（）”中包含了操作数，当然操作数可以为空</span><br><span class="line">//还包括了一些可选内容，如后继基本块、特性、区域、属性</span><br><span class="line">//最后是符号“：”以及操作的类型</span><br><span class="line">generic-operation     ::= string-literal `(` value-use-list? `)` </span><br><span class="line">                          successor-list? dictionary-properties? </span><br><span class="line">                          region-list? dictionary-attribute?</span><br><span class="line">                          `:` function-type</span><br><span class="line">//自定义操作格式，由开发者提供</span><br><span class="line">custom-operation      ::= bare-id custom-operation-format</span><br><span class="line">//操作结果，结果可以是多个，中间以符号“，”分割</span><br><span class="line">op-result-list        ::= op-result (`,` op-result)* `=`</span><br><span class="line">//每个结果还可以包括多个子结果，以符号“：”跟数字的方式获取第几个子结果</span><br><span class="line">op-result             ::= value-id (`:` integer-literal)?</span><br><span class="line">//后继基本块以符号“[”开始，以符号“]”结束，中间是后继基本块</span><br><span class="line">//当存在多个后继时以符号“，”分割</span><br><span class="line">successor-list        ::= `[` successor (`,` successor)* `]`</span><br><span class="line">//操作结束后访问的后继基本块，如果后继基本块由基本块参数，需要提供</span><br><span class="line">successor             ::= caret-id (`:` block-arg-list)?</span><br><span class="line">//操作的特性，以符号“&lt;”开头，以符号“&gt;”结束，中间是字典属性</span><br><span class="line">dictionary-properties ::= `&lt;` dictionary-attribute `&gt;`</span><br><span class="line">//操作的区域以符号“（”开头，以符号“）”结束,当存在多个区域时以符号“，”分割</span><br><span class="line">region-list           ::= `(` region (`,` region)* `)`</span><br><span class="line">//字典属性以符号“&#123;”开头，以符号“&#125;”结束,当存在多个区域时以符号“，”分割</span><br><span class="line">dictionary-attribute  ::= `&#123;` (attribute-entry (`,` attribute-entry)*)? `&#125;`</span><br><span class="line">//操作的位置信息，以字符串“loc”开头，跟符号“（”开头，位置信息、符号“）”结束</span><br><span class="line">trailing-location     ::= `loc` `(` location `)`</span><br></pre></td></tr></table></figure>
<p>在2.1.5节提到操作的结构是嵌套结构，操作包含了区域、区域有包含了基本块。区域和基本块的文法如代码3-29所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//第一基本块称为“入口基本块”</span><br><span class="line">region      ::= `&#123;` entry-block? block* `&#125;`</span><br><span class="line">//入口基本块至少包括一个操作，和一般的基本块相比可以没有标号</span><br><span class="line">entry-block ::= operation+</span><br><span class="line">//基本块文法，由基本块标号和操作组成</span><br><span class="line">block           ::= block-label operation+</span><br><span class="line">//基本块标号有基本块ID和基本块参数组成，并以符号“：”结尾</span><br><span class="line">block-label     ::= block-id block-arg-list? `:`</span><br><span class="line">//基本块ID是以符号“^”开头</span><br><span class="line">block-id        ::= caret-id</span><br><span class="line">caret-id        ::= `^` suffix-id</span><br><span class="line">value-id-and-type ::= value-id `:` type</span><br><span class="line">//基本块参数以符号“（”开头，以符号“）”结束，中间为参数类列</span><br><span class="line">//参数列表中的参数以符号“，”间隔</span><br><span class="line">value-id-and-type-list ::= value-id-and-type (`,` value-id-and-type)*</span><br><span class="line">block-arg-list ::= `(` value-id-and-type-list? `)`</span><br></pre></td></tr></table></figure>
<p>根据上述文法MLIR框架很容易完成序列化和反序列化。</p>
<h2 id="3-4方言"><a href="#3-4方言" class="headerlink" title="3.4方言"></a>3.4方言</h2><p>方言作为操作、类型和属性的管理者，首先要定义方言，然后将操作、类型和属性注册到方言，从而实现管理。同时在本节以内建方言为例，介绍具体定义的类型、属性和操作。</p>
<h3 id="3-4-1方言定义"><a href="#3-4-1方言定义" class="headerlink" title="3.4.1方言定义"></a>3.4.1方言定义</h3><p>下面以arith方言为例介绍方言的定义。</p>
<h4 id="TD定义-2"><a href="#TD定义-2" class="headerlink" title="TD定义"></a>TD定义</h4><p>首先在TD中定义操作，arith方言定义在TD中的定义如代码3-30所示。</p>
<figure class="highlight plaintext"><figcaption><span>Arith_Dialect : Dialect &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  let name = &quot;arith&quot;; //方言名</span><br><span class="line">  let cppNamespace = &quot;::mlir::arith&quot;;//cpp代码的命名空间</span><br><span class="line">  let description = [&#123; //描述</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">  let hasConstantMaterializer = 1; //生成常量操作的函数</span><br><span class="line">  let useDefaultAttributePrinterParser = 1;//解析属性的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在arith方言中几个字段的主要含义如下：</p>
<ul>
<li>name：该字段名字是方言管理的操作、类型和属性的命名空间，例如arith中的操作op都是形如arith.op这样格式。</li>
<li>cppNamespace：该字段是生成C++代码的命名空间。</li>
<li>description：arith方言的描述信息。</li>
<li>hasConstantMaterializer：该字段表示mlir-tblgen工具会为arith方言生成一个函数名为materializeConstant的声明，开发者需要进行实现。其目的是为了生成常量操作对象，例如在常量折叠中需要生成一个新的常量对象。</li>
<li>useDefaultAttributePrinterParser：该字段表示mlir-tblgen工具会为arith方言生成函数名为parseAttribute、printAttribute的声明，用于解析和输出属性。</li>
</ul>
<h4 id="从TD到记录-2"><a href="#从TD到记录-2" class="headerlink" title="从TD到记录"></a>从TD到记录</h4><p>接下来使用mlir-gblgen工具解析TD文件，将其翻译为记录信息，arith方言对应的记录如代码3-31所示。</p>
<figure class="highlight plaintext"><figcaption><span>Arith_Dialect &#123;// Dialect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  string name = &quot;arith&quot;;</span><br><span class="line">  string summary = ?;</span><br><span class="line">  code description = [&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;];</span><br><span class="line">  list&lt;string&gt; dependentDialects = [];//方言依赖的其它方言，此处为空</span><br><span class="line">  string cppNamespace = &quot;::mlir::arith&quot;;</span><br><span class="line">  string extraClassDeclaration = &quot;&quot;;//为arith方言对应的cpp类添加一些额外声明</span><br><span class="line">  bit hasConstantMaterializer = 1;</span><br><span class="line">  bit hasNonDefaultDestructor = 0;//是否提供默认的析构</span><br><span class="line">  bit hasOperationAttrVerify = 0;//是否添加操作属性验证函数</span><br><span class="line">  bit hasRegionArgAttrVerify = 0;//是否添加区域参数验证函数</span><br><span class="line">  bit hasRegionResultAttrVerify = 0;//是否添加区域结果验证函数</span><br><span class="line">  bit hasOperationInterfaceFallback = 0;//方言是否有操作接口回调</span><br><span class="line">  bit useDefaultAttributePrinterParser = 1;//方言是否使用默认的属性解析</span><br><span class="line">  bit useDefaultTypePrinterParser = 0;//使用是否使用默认的类型解析</span><br><span class="line">  bit hasCanonicalizer = 0;//方言是否有归一化函数</span><br><span class="line">  bit isExtensible = 0;//方言是否是扩展方言</span><br><span class="line">  bit usePropertiesForAttributes = 1;//是否允许特性存储到属性中</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个记录比较清晰，对比TD文件和记录，可发现在TD文件中能够为方言定义许多字段，这些字段都有有些特殊的用途，这里唯一需要注意的字段是dependentDialects，它表示方言依赖的其他方言。在MLIR框架中当对当前方言进行降级或者变换时，可能会使用到其他方言的操作，此时需要指定依赖，否则可能出错。</p>
<h4 id="TD到C-代码"><a href="#TD到C-代码" class="headerlink" title="TD到C++代码"></a>TD到C++代码</h4><p>再接下来使用mlir-tblgen工具从记录提取信息，生成C++类。对于代码3-31使用mlir-tblgen工具生成的C++类如代码3-32所示，它是arith方言对应的头文件。</p>
<figure class="highlight plaintext"><figcaption><span>ArithDialect : public ::mlir::Dialect &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//arith方言显式构造函数</span><br><span class="line">  explicit ArithDialect(::mlir::MLIRContext *context);</span><br><span class="line">//方言的初始化函数，在初始化函数中会注册方言管理的操作、类型和属性</span><br><span class="line">  void initialize();</span><br><span class="line">  friend class ::mlir::MLIRContext;</span><br><span class="line">public:</span><br><span class="line">  ~ArithDialect() override;</span><br><span class="line">//方言名</span><br><span class="line">  static constexpr ::llvm::StringLiteral getDialectNamespace() &#123;</span><br><span class="line">    return ::llvm::StringLiteral(&quot;arith&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ///方言中属性的解析</span><br><span class="line">  ::mlir::Attribute parseAttribute(::mlir::DialectAsmParser &amp;parser,</span><br><span class="line">                                   ::mlir::Type type) const override;</span><br><span class="line">  /// 方言中属性的输出</span><br><span class="line">  void printAttribute(::mlir::Attribute attr,</span><br><span class="line">                      ::mlir::DialectAsmPrinter &amp;os) const override;</span><br><span class="line">  ///创建方言中的常量操作对象</span><br><span class="line">  ::mlir::Operation *materializeConstant(::mlir::OpBuilder &amp;builder,</span><br><span class="line">                                         ::mlir::Attribute value,</span><br><span class="line">                                         ::mlir::Type type,</span><br><span class="line">                                         ::mlir::Location loc) override;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//arith方言对应的ID</span><br><span class="line">MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::arith::ArithDialect)</span><br></pre></td></tr></table></figure>
<p>这段C++代码中需要开发者实现的是initialize函数，根据3.1.1、3.3.1介绍可以看出，它用于将类型、属性、操作注册到方言。而initialize函数本身会被airth方言的构造函数调用，arith方言的构造函数由mlir-tblgen工具自动生成，如代码3-32所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::arith::ArithDialect)</span><br><span class="line">//方言的构造函数</span><br><span class="line">ArithDialect::ArithDialect(::mlir::MLIRContext *context)</span><br><span class="line">    : ::mlir::Dialect(getDialectNamespace(), context, ::mlir::TypeID::get&lt;ArithDialect&gt;()) &#123;</span><br><span class="line">//调用initialize函数</span><br><span class="line">  initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么剩下的问题就是arith方言何时被初始化？以及初始化对象放在放在哪里？<br>简单的回答就是MLIR框架提供了DialectRegistry类用于管理注册方言，它包含了一个Map结构，其key为方言的名字，value为方言的构造器。当开发者调用DialectRegistry中的insert函数时会将方言添加到DialectRegistry对象中，当使用方言时通过map查找，如果找到则执行构造器实例化方言对象。<br>在3.1中提到MLIR框架使用一个“全局”唯一的MLIRContext对象，用于管理编译过程。在MLIRContext中包含了一个DialectRegistry对象，用于保存注册的方言。当使用时通过getOrLoadDialect函数获取方言（第一次使用方言时需要实例化，然后缓存方言对象共后续使用）。</p>
<h4 id="方言接口"><a href="#方言接口" class="headerlink" title="方言接口"></a>方言接口</h4><p>MLIR框架还允许为方言定义接口，便于对方言进行统一处理。例如在LLVM方言（有多个方言，包括LLVM——定义一般LLVM IR、SVE——定义ARMSVE指令Intrinsic、GPU——定义GPU操作，等方言，在第11章介绍）要到LLVM IR翻译过程时，通过定义接口，能够对所有的LLVM方言进行处理。目前MLIR框架对于翻译过程定义接口是LLVMTranslationDialectInterface，在接口中提供了convertOperation函数，其目的是将当前方言中的算子转换为LLVM IR。<br>再例如MLIR框架定义了DialectInlineInterface接口，该接口文件定义了一些接口，用于判断Call调用、操作、区域是否可以内联（Inline）。需要支持内联的各个方言就可以实现自己的内联逻辑，例如affine、bufferize、arith、cf、func等方言都可以根据自己业务特点决定是否实现内联优化。同时MLIR框架提供了Inliner Pass用于将所有实现InlineInterface的方言都收集起来，在该Pass中针对方言依次执行内联功能。</p>
<h3 id="3-4-2扩展方言"><a href="#3-4-2扩展方言" class="headerlink" title="3.4.2扩展方言"></a>3.4.2扩展方言</h3><p>MLIR的框架设计非常好，提供方言的扩展能力，可以对社区存在的方言进行扩展，从而满足自定义需求，另外还可以针对Transform方言（这是MLIR社区提供的一个方言）增加新的操作，用于处理变换（在第12章介绍）。而这些功能都是基于扩展方言功能进行实现的。扩展方言的本质是为待扩展的方言增加额外操作或者新的接口，这些新增的操作和接口和已经定义的操作和接口具有相同的地位。<br>在MLIRContext的DialectRegistry类结构中除了包含一个map结构用于保存一般方言外，还有一个extensions字段（是vector类型）用于存储扩展方言，扩展方言的目的是对方言进行扩展，其基类如代码3-33所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class DialectExtensionBase &#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~DialectExtensionBase();</span><br><span class="line">  //扩展方言依赖的方言</span><br><span class="line">  ArrayRef&lt;StringRef&gt; getRequiredDialects() const &#123; return dialectNames; &#125;</span><br><span class="line">  //对方言进行扩展，第一个参数功能类，第二个参数是一个方言数组，表示可以同时对多个</span><br><span class="line">//方言扩展。可以将一个功能类扩展到多个方言中</span><br><span class="line">  virtual void apply(MLIRContext *context,</span><br><span class="line">                     MutableArrayRef&lt;Dialect *&gt; dialects) const = 0;</span><br><span class="line">  virtual std::unique_ptr&lt;DialectExtensionBase&gt; clone() const = 0;</span><br><span class="line">protected:</span><br><span class="line">  DialectExtensionBase(ArrayRef&lt;StringRef&gt; dialectNames)</span><br><span class="line">      : dialectNames(dialectNames.begin(), dialectNames.end()) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">  SmallVector&lt;StringRef&gt; dialectNames;</span><br><span class="line">&#125;;</span><br><span class="line">//扩展功能类，第一个参数为扩展功能类，第二个参数为待扩展的方言</span><br><span class="line">template &lt;typename DerivedT, typename... DialectsT&gt;</span><br><span class="line">class DialectExtension : public DialectExtensionBase &#123;</span><br><span class="line">public:</span><br><span class="line">  //扩展类需要实现apply，注意该函数和基类的apply参数并不相同</span><br><span class="line">  virtual void apply(MLIRContext *context, DialectsT *...dialects) const = 0;</span><br><span class="line">  //扩展类实现的clone函数</span><br><span class="line">  std::unique_ptr&lt;DialectExtensionBase&gt; clone() const final &#123;</span><br><span class="line">    return std::make_unique&lt;DerivedT&gt;(static_cast&lt;const DerivedT &amp;&gt;(*this));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">  DialectExtension()  : DialectExtensionBase(</span><br><span class="line">        ArrayRef&lt;StringRef&gt;(&#123;DialectsT::getDialectNamespace()...&#125;)) &#123;&#125;</span><br><span class="line">  //该函数用于重载基类的apply方法，同时调用派生类定义的apply虚函数</span><br><span class="line">  void apply(MLIRContext *context,</span><br><span class="line">               MutableArrayRef&lt;Dialect *&gt; dialects) const final &#123;</span><br><span class="line">    unsigned dialectIdx = 0;</span><br><span class="line">    auto derivedDialects = std::tuple&lt;DialectsT *...&gt;&#123;</span><br><span class="line">        static_cast&lt;DialectsT *&gt;(dialects[dialectIdx++])...&#125;;</span><br><span class="line">    //此处调用派生类定义的apply函数</span><br><span class="line">    std::apply([&amp;](DialectsT *...dialect) &#123; apply(context, dialect...); &#125;, derivedDialects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在DialectExtension中有apply方法，它接受MLIRContext和方言，apply的目的就是针对方言进行扩展，方言扩展后功能类中定义的操作、接口等都添加到方言中。apply调用是由框架完成，在DialectReistry中还定义了applyExtensions方法，它会调用MLIRContext的extensions字段中的apply方法，从而实现对方言的扩展。换句话说，如果要支持扩展方言，开发者只需要定义自己的扩展类并继承于DialectExtension，同时实现apply方法，MLIR框架就可以完成对方言的扩展。<br>例如在MLIR中可以为方言添加一个接口，用于表示方言具有相同的特性。例如arith方言需要添加接口，这个接口用于表示将arith方言降级到LLVM IR（关于接口在第4章讨论），如代码3-34所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void mlir::arith::registerConvertArithToLLVMInterface(</span><br><span class="line">    DialectRegistry &amp;registry) &#123;</span><br><span class="line">  //addExtensions的参数为一个函数指针</span><br><span class="line">  registry.addExtension(+[](MLIRContext *ctx, arith::ArithDialect *dialect) &#123;</span><br><span class="line">    dialect-&gt;addInterfaces&lt;ArithToLLVMDialectInterface&gt;();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码3-34中DialectRegistry中的addExtnesions函数目的是将函数指针注册到DialectRegistry中的extensions字段。在addExtensions中定义一个临时的Extension类继承于DialectExtension，并实现apply函数，而apply函数会调用addExtensions的函数指针。代码如代码3-35所示。</p>
<figure class="highlight plaintext"><figcaption><span><typename... DialectsT></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void  addExtension(std::function&lt;void(MLIRContext *, DialectsT *...)&gt; extensionFn) &#123;</span><br><span class="line">  using ExtensionFnT = std::function&lt;void(MLIRContext *, DialectsT * ...)&gt;;</span><br><span class="line">//定义临时类Extension，将开发者定义的函数指针封装到apply中调用</span><br><span class="line">  struct Extension : public DialectExtension&lt;Extension, DialectsT...&gt; &#123;</span><br><span class="line">    Extension(const Extension &amp;) = default;</span><br><span class="line">    Extension(ExtensionFnT extensionFn)</span><br><span class="line">          : extensionFn(std::move(extensionFn)) &#123;&#125;</span><br><span class="line">    ~Extension() override = default;</span><br><span class="line">    //这里的apply函数被代码3-33中apply函数调用</span><br><span class="line">    void apply(MLIRContext *context, DialectsT *...dialects) const final &#123;</span><br><span class="line">      //此处调用开发者传递的函数指针</span><br><span class="line">      extensionFn(context, dialects...);</span><br><span class="line">    &#125;</span><br><span class="line">    ExtensionFnT extensionFn;</span><br><span class="line">  &#125;;</span><br><span class="line">//通过addExtension将临时类示例化对象，并传递至DialectRegistry中的extensions字段</span><br><span class="line">  addExtension(std::make_unique&lt;Extension&gt;(std::move(extensionFn)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MLIR框架会在合适的地方调用执行extensions字段的apply函数（例如在getOrLoadDialect函数中加载方言时进行调用），从而实现方言的扩展。<br>这个地方还未完成。对于接口应该是添加到原来方言的一个位置，从而可以视为和原来接口一样的功能被使用。<br>对于操作和原来方言的操作的关系<br>最好给出图。</p>
<h3 id="3-4-3方言管理操作、类型和属性"><a href="#3-4-3方言管理操作、类型和属性" class="headerlink" title="3.4.3方言管理操作、类型和属性"></a>3.4.3方言管理操作、类型和属性</h3><p>类型、属性和操作都注册到方言，方言负责管理它们的对象。由于类型和属性通常只需要一个对象，而操作对象则应该随着代码产生和消亡，所以方言需要区别管理类型&#x2F;属性和操作。<br>对于类型对象也有2种不同的分类，有些类型可以接受参数从而实例化出不同的类型，而有写类型并没有参数，都是单例对象。对于单例对象，在方言构造时就会实例化相应的对象；而对于有参数的类型，处理稍有不同，在3.1中提到类型对象分成2部分，Type和TypeStorage，而TypeStorage接受参数实例化不同的类型存储对象。因此在方言构造时只会实例化Type对象，但是并未实例化TypeStorage对象，只有当真正使用类型对象时才会根据参数实例化TypeStorage对象。单例对象顾名思义在方言中只有一个实例，参数类型对象当参数相同也只有一个实例，只有参数不同时才会产生不同的类型对象。类型对象在方言中通过键—值（Key—Value）的map结构进行管理。<br>属性的管理方式和类型一致。<br>操作的管理则有所不同，由于操作对象是随着代码产出或者消亡，所以方言只能管理操作元数据，而非操作对象。在MLIR框架中设计了RegisteredOperationName用于管理操作元数据，元数据包括操作定义的各种信息，通过元数据可以实例化出操作对象。<br>方言管理操作、类型和属性的示意图如3-6所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17161092896495.jpg" class="">

<p>Types、Attribute不是存储元数据<br>注意，图3-6表达是方言和操作、类型、属性的管理关系，并非真实存储结构图。真实的存储结构图在3.5节介绍。</p>
<h3 id="3-4-4方言示例：内建方言"><a href="#3-4-4方言示例：内建方言" class="headerlink" title="3.4.4方言示例：内建方言"></a>3.4.4方言示例：内建方言</h3><p>内建方言（Built-In Dialect）是MLIR框架中最基础方言，其目的是为整个MLIR其它方言提供可以直接使用的基本类型、属性和操作，它并不会参与方言变换、操作匹配等工作。下面简单内建方言的类型、属性和操作。由于内建方言是最基础的方言，它默认会被加载到MLIRContext中。<br>注意：为什么只有内建方言定义的类型可以被其它方言使用？<br>在3.4.1节方言的定义可以看到方言类都有一个命名空间，例如airh方言对应的命名空间为::mlir::arith，同样地其它方言也是类似格式，这样不同方言中操作、类型、属性都被限制在不同的命名空间中，所以默认情况下不同方言类型都不可见，因此无法访问。为了让内建方言类型被其它所有方言访问，内建方言的命名空间为::mlir，这个命名空间是所有方言命名空间的上一层空间，因此只有内建方言的类型被其它方言直接使用。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>内建方言中类型通常也称为内建类型（Built-In Type），主要分为2类：</p>
<ul>
<li>单例类型：在MLIR运行系统中仅仅保留一份类型对象，例如bf16、f8、f32、index、i1、i8、i16、i32、i64等类型。</li>
<li>多例类型：在MLIR运行系统中可能存在多个类型对象，例如Integer类型，开发者可以自定义任意长度的整数如i7（注意上面提到的i1、i8、i16、i32、i64都是Integer类型，其实Integer是它们的父类）；例如Complex类型，可以接受f32和Integer；再例如Function类型，在内建类型的函数类型是由参数类型和返回类型构成（这和C&#x2F;C++语言中函数类型的定义略有不同）；另外还有一些高级类型，如RankedMemRef、RankedTensor、UnRankedMemRef和UnRankedTensor、Vector类型等。<br>由于单例类型比较简单，基本上和读者熟悉的编程语言中的类型基本一致。而高级类型则非常少见，这里稍微展开介绍。<br>RankedMemRef表示维度以及每维的长度都是已知的内存区域。为了区分不同的内存区域类型，它有4个字段，如表3-1所示。<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256977135851.jpg" class=""></li>
</ul>
<p>类似地RankedTensor、Vector都有Shape信息。也就是说它们是静态类型，在编译时就知道类型的维度、长度、占用的内存大小、访问方式等。<br>而UnRankedMemRef、UnRankedTensor则没有Shape信息，只有元素类型。开发者可以根据有无Shape信息判断类型是静态还是动态。<br>注意：对于部分类型来说除了提供get函数获取类型对象外，在代码仓中还可以看到有clone函数用于创建新的类型对象。主要原因是get函数可以方便的自动代码生成框架结合，而在开发者进行一些优化时可能也需要创建一个新的类型，当然新的类型一般都是基于原始类型变换得到，所以MLIR框架中提供了clone函数用于生成新的类型。最为典型的一个场景就是因为优化等需要对Shape形状进行变换，而变换后新的Shape构成的类型对象和原始类型对象并不相同，此时就是需要使用clone函数创建新的类型对象。<br>还有一个值得注意的是，通常类型对象一经创建就不会再发生变化，例如上面提到的Complex、MemRef等。但是在实际中可能会遇到类型对象可能发生变化的情况，例如StructType可以有多个子类型组成，当子类型对象发生变化，那么Struct类型对象也会发生变化。对于这样的情况，在实现类型对象时一方面对于类型的识别最好只使用不变的部分，另外MLIR框架提供了mutate函数用于更新类型对象，所以当遇到这样的情况需要开发者主动调用mutate函数确保类型对象正确。<br>另外每一个类型对象需要保证唯一性，因此在类型对象创建时首先确定是否已经创建过，为了达到这一目的，首先所有的类型对象需要保存起来（使用TypeUniquer存储，底层使用DenseMap），另外为了加速查找，通常要求类型实现时提供key、hash信息，方便进行查找、插入操作。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>内建方言中提供的属性主要2类。</p>
<ul>
<li>位置属性：主要用于提供源代码的位置信息，和操作进行关联，方便进行调试等。例如CallSiteLoc（调用点位置信息）、FileLineColLoc（文件和行号位置信息）、FusedLoc（融合位置信息，可以有多种位置信息组合）、NameLoc（命名的位置信息）、OpaqueLoc（不可知结构的位置信息，通常是指非MLIR提供的位置信息）、UnknownLoc（未知的位置信息）。</li>
<li>一般属性：为操作提供额外信息，主要有AffineMapAttr（AffineMap属性）、ArrayAttr（数组属性）、DenseArrayAttr（稠密数组属性，和ArrayAttr的区别在于该类型仅介绍浮点数和整数的元素，而ArrayAttr可以是任意属性）、DenseIntOrFPElementsAttr（多维浮点数或整数元素属性，结果是Tensor或者Vector类型）、DenseResourceElementsAttr（资源属性，用于接受外部资源作为属性，该属性要求Resource按照一定格式进行存储和读取）、DenseStringElementsAttr（多维字符串属性，结果是Tensor或者Vector类型）、DictionaryAttr（key-value格式的属性对）、FloatAttr（浮点数属性）、IntegerAttr（整数属性）、IntegerSetAttr（整数集属性，通常有不等式进行描述）、OpaqueAttr（不可知属性，表示方言并未定义该属性）、SparseElementsAttr（稀疏矩阵描述属性，结果是Tensor或者Vector类型）、StringAttr（字符串属性）、SymbolRefAttr（符号引用属性）、TypeAttr（类型属性）、UnitAttr（单元属性）、StridedLayoutAttr（条状布局属性）。<br>属性的使用和类型非常类似。</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>内建方言定义的操作有2个，分别为ModuleOp和UnrealizedConversionCastOp。</p>
<ul>
<li>ModuleOp：定义IR顶层操作，它包含区域的类型为GraphRegion，即区域内的操作不需要满足SSA形式，甚至可以先使用后定义。由于它是IR的顶层操作，所以任意其它的操作应该是ModuleOp的负载（payload），也就是说其它任意的操作的最顶级操作都是ModuleOp。</li>
<li>UnrealizedConversionCastOp：这个操作是指方言转换过程中由于类型缺失，需要插入额外的强制类型转换操作。</li>
</ul>
<h2 id="3-5编译上下文管理"><a href="#3-5编译上下文管理" class="headerlink" title="3.5编译上下文管理"></a>3.5编译上下文管理</h2><p>MLIR框架通过“全局”唯一的MLIRContext管理方言、内建类型、内建属性等，方言管理它自己的操作、类型和属性。方言Dialect结构如图3-7所示。<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256978084756.jpg" class=""></p>
<p>在3.1.1、3.3.1提到将类型、操作注册到方言中，但是方言并没有相应的数据结构存储这些信息，实际上它们被存储到MLIRContext中，MLIRContext结构如图3-8所示。</p>
<img src="/2024/05/19/MLIR-Dialect-Op-Type-Attr/17256978666317.jpg" class="">


<p>在图中可以看到内建类型int1Ty、floatType等以及内建属性falseAttr、unitAttr等都在MLIRContext中，而注册到方言中的操作元数据在字段registeredOpertion中，类型在字段typeUniquer中、属性在字段attributeUniquer中。<br>注意：目前MLIRContext对于对象的管理还不够精细，对于这些元数据会一直伴随着MLIRContext的生命周期，当一些方言不再被使用后，方言关联的元数据并不会释放。<br>注意：我们一直说MLIRContext是“全局”唯一并不准确，由于MLIR可以支持多线程并行编译，MLIRContext仅仅是在单个编译线程唯一。<br>最后简单总结一下，对于一般开发者来说如何使用MLIR的方言。示例如代码3-35所示。</p>
<p>&#96;&#96;&#x2F;&#x2F; 定义DialectRegistry对象<br>DialectRegistry registry;<br>&#x2F;&#x2F; 注册需要使用的方言，例如这里使用openAcc、affine等<br>registry.insert&lt;acc::OpenACCDialect,<br>                  affine::AffineDialect,<br>                  amdgpu::AMDGPUDialect,<br>                  amx::AMXDialect,<br>                  arith::ArithDialect,<br>  ……</p>
<blockquote>
<p>;<br>&#x2F;&#x2F; 注册扩展方言，这样就可以为社区方言进行扩展<br>registry.addExtensions&lt;***DialectExtension&gt;();<br>&#x2F;&#x2F; 将注册的方言注册到MLIRContext<br>MLIRContext context(registry);<br>&#x2F;&#x2F; 后续就可以使用MLIRContext中的操作、类型、属性等</p>
</blockquote>
<pre><code>
&lt;!-- more --&gt;
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MLIR/" rel="tag"># MLIR</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/19/MLIR-Overview3/" rel="prev" title="第2章：MLIR-设计、实现与架构">
                  <i class="fa fa-angle-left"></i> 第2章：MLIR-设计、实现与架构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/15/mlir-constraint/" rel="next" title="第4章（1）：约束">
                  第4章（1）：约束 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">inside compiler</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"inside-compiler","repo":"inside-compiler.github.io","client_id":"3b662fd9edd646229c79","client_secret":"312a2514c4029a47341087757f0c051786144c77","admin_user":"fiking","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"labels":["gitalk"],"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"33b9a9fb0f7345e0656232708b65b359"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
